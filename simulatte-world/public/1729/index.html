<!DOCTYPE html>
<html lang="en">
  <head id="pageHead">
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1729 - REPLOID v0.0.3</title>
    <style id="pageStyle">
      :root {
        --main-bg: black;
        --main-fg: white;
        --border-color: white;
        --input-padding: 12px;
        --button-padding: 12px 20px;
        --fieldset-padding: 25px;
        --gap-normal: 20px;
        --gap-small: 10px;
        --font-size-normal: 14px;
        --font-size-large: 1.5em;
        --font-size-xlarge: 2em;
        --context-warning-threshold: 900000;
        --border-modified: 2px dashed yellow;
        --border-input: 1px dotted var(--border-color);
        --border-output: 1px solid var(--border-color);
        --border-info: 1px dashed gray;
        --border-error: 1px solid red;
      }
      body {
        font-family: monospace;
        background-color: var(--main-bg);
        color: var(--main-fg);
        margin: 0;
        padding: var(--fieldset-padding);
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        font-size: var(--font-size-normal);
      }
      h1,
      h2,
      h3 {
        border-bottom: 2px solid var(--border-color);
        padding-bottom: var(--gap-small);
        margin-top: 30px;
        margin-bottom: var(--gap-normal);
        font-weight: bold;
      }
      h1 {
        font-size: var(--font-size-xlarge);
        text-align: center;
        position: relative;
        cursor: default;
      }
      h1 .reploid-text::before,
      h1 .dreamer-text::before {
        content: "";
        position: absolute;
        bottom: -5px;
        left: 50%;
        width: 0;
        height: 2px;
        background-color: var(--main-fg);
        transition: all 0.3s ease-in-out;
        transform: translateX(-50%);
      }
      h1 .reploid-text:hover::before,
      h1 .dreamer-text:hover::before {
        width: 100%;
      }
      h1 .reploid-text,
      h1 .dreamer-text {
        display: inline-block;
      }
      h2 {
        font-size: var(--font-size-large);
      }
      h3 {
        font-size: 1.2em;
        border-bottom-width: 1px;
        margin-top: var(--gap-normal);
        margin-bottom: 15px;
      }
      fieldset {
        border: 2px solid var(--border-color);
        padding: var(--fieldset-padding);
        margin-bottom: 30px;
        background-color: var(--main-bg);
      }
      legend {
        font-weight: bold;
        font-size: 1.3em;
        padding: 0 15px;
        margin-left: 15px;
        background-color: var(--main-bg);
        color: var(--main-fg);
      }
      label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        flex-shrink: 0;
        text-align: right;
        min-width: 150px;
        padding-right: 10px;
      }
      textarea,
      pre,
      input[type="text"],
      input[type="number"],
      input[type="password"],
      select {
        background-color: var(--main-bg);
        color: var(--main-fg);
        border: 1px solid var(--border-color);
        padding: var(--input-padding);
        width: 100%;
        font-family: inherit;
        margin-bottom: 15px;
        box-sizing: border-box;
        font-size: 1em;
      }
      textarea {
        min-height: 150px;
        line-height: 1.5;
      }
      #systemGoalInput,
      #metaGoalInput {
        min-height: 100px;
      }
      pre {
        min-height: 50px;
        max-height: 300px;
        overflow: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        border: var(--border-info);
        padding: 10px;
        margin-bottom: 15px;
      }
      .artifact-display pre {
        border: var(--border-output);
      }
      .artifact-display pre.modified {
        border: var(--border-modified);
        font-weight: bold;
      }
      .artifact-display pre.input {
        border: var(--border-input);
        opacity: 0.8;
      }
      .artifact-display pre.info {
        border: var(--border-info);
      }
      .artifact-display pre.error {
        border: var(--border-error);
        color: red;
      }
      .artifact-label {
        display: block;
        font-weight: bold;
        margin-bottom: 5px;
        font-size: 0.9em;
        text-transform: uppercase;
        color: gray;
      }
      .artifact-label .change-indicator {
        color: yellow;
        font-weight: bold;
        margin-left: 5px;
      }
      .artifact-label .source-indicator {
        color: cyan;
        font-size: 0.9em;
        margin-left: 5px;
      }
      input[type="number"],
      select {
        width: auto;
        min-width: 80px;
        padding: 10px 12px;
      }
      button {
        background-color: var(--main-bg);
        color: var(--main-fg);
        border: 2px solid var(--border-color);
        padding: var(--button-padding);
        cursor: pointer;
        margin: 0;
        font-family: inherit;
        font-size: 1em;
        font-weight: bold;
      }
      button:hover:not(:disabled) {
        background-color: var(--main-fg);
        color: var(--main-bg);
      }
      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .flex-row {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: var(--gap-normal);
        margin-bottom: var(--gap-normal);
        align-items: flex-start;
      }
      .flex-col {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-width: 300px;
      }
      .config-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 15px var(--gap-normal);
        align-items: baseline;
      }
      .config-item {
        display: flex;
        align-items: baseline;
        gap: var(--gap-small);
      }
      .config-item label {
        margin-bottom: 0;
        flex-basis: 180px;
        flex-shrink: 0;
      }
      .config-item input,
      .config-item select {
        flex-grow: 1;
        width: auto;
        min-width: 60px;
        margin-bottom: 0;
      }
      .persona-inputs {
        display: flex;
        gap: 5px;
        flex-grow: 1;
      }
      .persona-inputs input {
        min-width: 50px;
        text-align: right;
      }
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: var(--gap-small) var(--gap-normal);
        margin-top: var(--gap-normal);
      }
      .metric-item {
        border: 1px solid var(--border-color);
        padding: 8px 12px;
        background-color: var(--main-bg);
        font-size: 0.95em;
        text-align: center;
      }
      .metric-item strong {
        display: block;
        font-size: 1.1em;
        margin-top: 3px;
      }
      #coreMetricsDisplay {
        grid-template-columns: repeat(4, 1fr);
      }
      #rollingMetricsDisplay {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        max-width: calc(4 * 200px + 3 * var(--gap-normal));
      }
      .timeline {
        list-style-type: none;
        padding: 0;
        max-height: 800px;
        overflow-y: auto;
        border: 2px solid var(--border-color);
        background-color: var(--main-bg);
        margin-top: var(--gap-small);
      }
      .timeline li {
        border-bottom: 1px solid var(--border-color);
        padding: 8px var(--gap-normal) 8px 15px;
        margin-bottom: 0;
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: default;
      }
      .timeline li:last-child {
        border-bottom: none;
      }
      .timeline li.summary {
        background-color: #111;
        font-size: 0.9em;
        color: #ccc;
        cursor: pointer;
      }
      .timeline li.summary:hover {
        background-color: #222;
        color: var(--main-fg);
      }
      .timeline li.core-step {
        padding-left: var(--gap-normal);
        font-weight: bold;
        background-color: #080808;
        margin-top: 5px;
        border-top: 1px dashed gray;
      }
      .timeline li.sub-step {
        padding-left: 45px;
        font-size: 0.95em;
        opacity: 0.9;
      }
      .timeline li::before {
        content: attr(data-iteration);
        background-color: var(--main-fg);
        color: var(--main-bg);
        padding: 3px 6px;
        border-radius: 0;
        font-size: 0.85em;
        font-weight: bold;
        flex-shrink: 0;
        align-self: flex-start;
        margin-top: 2px;
      }
      .timeline li .log-icon {
        font-size: 1.1em;
        width: 20px;
        text-align: center;
        flex-shrink: 0;
        display: inline-block;
      }
      .timeline li span {
        flex-grow: 1;
        line-height: 1.4;
      }
      .timeline .animated-icon {
        animation: spin 1s linear infinite;
        display: inline-block;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      #diagram-display-container {
        display: flex;
        gap: var(--gap-normal);
        margin-top: 15px;
      }
      #diagram-json-container {
        flex: 1 1 25%;
      }
      #diagram-svg-container {
        flex: 1 1 75%;
        min-height: 400px;
        border: 1px solid var(--border-color);
        background-color: var(--main-fg);
        color: var(--main-bg);
        overflow: auto;
        padding: 10px;
      }
      #diagram-svg-container h3 {
        margin-top: 0;
        color: var(--main-bg);
        border-color: var(--main-bg);
      }
      #diagram-json-display {
        min-height: 400px;
      }
      #uiRenderOutput,
      #metaSandboxOutput {
        width: 100%;
        min-height: 500px;
        border: 1px solid var(--border-color);
        background-color: var(--main-fg);
        margin-top: 15px;
      }
      .hidden {
        display: none !important;
      }
      .api-key-input-container {
        display: flex;
        align-items: baseline;
        gap: var(--gap-small);
        flex-grow: 1;
      }
      .api-key-input-container label {
        flex-basis: 180px;
        flex-shrink: 0;
      }
      .api-key-input-container input {
        flex-grow: 1;
        margin-bottom: 0;
      }
      .controls-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: var(--gap-small);
        align-items: center;
        margin-top: 15px;
      }
      .state-io-buttons {
        display: contents;
      }
      .artifact-section {
        margin-bottom: var(--gap-normal);
        padding-bottom: var(--gap-normal);
        border-bottom: 1px dotted gray;
      }
      .artifact-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      .artifact-collection {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: var(--gap-normal);
      }
      .hitl-container {
        border: 1px dashed yellow;
        padding: 15px;
        margin-top: 15px;
        background-color: #111;
      }
      .hitl-container h3 {
        color: yellow;
        border-color: yellow;
        margin-top: 0;
      }
      .hitl-options label {
        display: block;
        margin-bottom: 8px;
        cursor: pointer;
      }
      .hitl-options input[type="checkbox"] {
        margin-right: 8px;
      }
      #humanEditArtifactTextarea {
        min-height: 150px;
        width: 100%;
        margin-top: 10px;
        background-color: #1a1a1a;
      }
      #metaSandboxContainer {
        border: 2px dashed cyan;
        padding: 15px;
        margin-top: 15px;
        background-color: #001111;
      }
      #metaSandboxContainer h3 {
        color: cyan;
        border-color: cyan;
        margin-top: 0;
      }
      #metaSandboxOutput {
        border-color: cyan;
      }
      #genesisStateDisplay {
        border-style: dotted;
        opacity: 0.8;
      }
      #genesisStateDisplay legend {
        color: gray;
      }
      #genesisDiagramContainer svg {
        max-height: 150px;
        width: auto;
        border: 1px solid gray;
      }
      #genesisDiagramJson {
        font-size: 0.8em;
        max-height: 150px;
      }
      .token-warning {
        color: yellow;
        font-weight: bold;
        border: 1px solid yellow;
        padding: 5px;
        margin-left: 10px;
        display: inline-block;
      }
      #statusIndicator {
        border: 1px solid gray;
        padding: 5px 10px;
        margin-left: 20px;
        display: inline-block;
        font-size: 0.9em;
        min-width: 150px;
        text-align: center;
      }
      #statusIndicator.active {
        border-color: yellow;
        color: yellow;
        font-weight: bold;
      }
      .core-loop-instructions ol {
        padding-left: 25px;
      }
      .core-loop-instructions li {
        margin-bottom: 8px;
      }
    </style>
  </head>
  <body id="pageBody">
    <div id="top"></div>
    <h1>
      <span class="reploid-text">REPLOID</span> (Reflective Embodiment Providing
      Logical Oversight for Intelligent
      <span class="dreamer-text">DREAMER</span> (Deep Recursive Exploration And
      Model-building Embodying <span class="reploid-text">REPLOID</span>))
    </h1>

    <fieldset id="genesisConfig">
      <legend>Current Configuration</legend>
      <div class="config-grid">
        <div class="config-item">
          <label
            for="lsdPersonaPercent"
            title="Influence ratio contribution for LSD persona."
            >LSD %:</label
          >
          <div class="persona-inputs">
            <input
              type="number"
              id="lsdPersonaPercent"
              value="50"
              min="0"
              max="100"
              step="1"
            />
          </div>
        </div>
        <div class="config-item">
          <label
            for="xyzPersonaPercent"
            title="Influence ratio contribution for XYZ persona."
            >XYZ %:</label
          >
          <div class="persona-inputs">
            <input
              type="number"
              id="xyzPersonaPercent"
              value="50"
              min="0"
              max="100"
              step="1"
              readonly
            />
          </div>
        </div>
        <div class="config-item">
          <label
            for="llmTurnProbability"
            title="Prob(0-100) LLM critiques if checks pass."
            >LLM Auto-Critique %:</label
          >
          <input
            type="number"
            id="llmTurnProbability"
            value="70"
            min="0"
            max="100"
            step="5"
          />
        </div>
        <div class="config-item">
          <label
            for="humanReviewProbability"
            title="Prob(0-100) cycle forced human review."
            >Forced Human Review %:</label
          >
          <input
            type="number"
            id="humanReviewProbability"
            value="36"
            min="0"
            max="100"
            step="5"
          />
        </div>
        <div class="config-item">
          <label
            for="maxCycleTime"
            title="Max time (s) per iteration before human review."
            >Max Cycle Time (s):</label
          >
          <input
            type="number"
            id="maxCycleTime"
            value="600"
            min="10"
            max="1800"
          />
        </div>
        <div class="config-item">
          <label
            for="autoCritiqueThreshold"
            title="Confidence (0-1) below which human review forced."
            >Confidence Threshold:</label
          >
          <input
            type="number"
            id="autoCritiqueThreshold"
            value="0.6"
            min="0"
            max="1"
            step="0.05"
          />
        </div>
        <div class="config-item">
          <label for="maxCycles" title="Max cycles (0=Inf)."
            >Max Cycles (0=Inf):</label
          >
          <input
            type="number"
            id="maxCycles"
            value="0"
            min="0"
            max="1000"
            step="1"
          />
        </div>
        <div class="config-item">
          <label
            for="htmlHistoryLimit"
            title="Num previous states for 'Go Back'."
            >Self-Mod History:</label
          >
          <input
            type="number"
            id="htmlHistoryLimit"
            value="5"
            min="1"
            max="20"
            step="1"
          />
        </div>
        <div class="config-item">
          <label
            for="pauseAfterCycles"
            title="Auto pause every N cycles (0=Off)."
            >Pause Every N Cycles:</label
          >
          <input
            type="number"
            id="pauseAfterCycles"
            value="10"
            min="0"
            max="100"
            step="1"
          />
        </div>
      </div>

      <h3>Core Metrics</h3>
      <div class="metrics-grid" id="coreMetricsDisplay">
        <div class="metric-item" id="metricTotalCycles">
          Cycles<strong id="totalCycles">0</strong>/<strong
            id="maxCyclesDisplay"
            >Inf</strong
          >
        </div>
        <div class="metric-item" id="metricAgentIterations">
          Agent Itr<strong id="agentIterations">0</strong>
        </div>
        <div class="metric-item" id="metricHumanInterventions">
          Human Int<strong id="humanInterventions">0</strong>
        </div>
        <div class="metric-item" id="metricCurrentGoal">
          Goal<strong id="currentGoal">Idle</strong>
        </div>
        <div class="metric-item" id="metricLastCritiqueType">
          Critique<strong id="lastCritiqueType">N/A</strong>
        </div>
        <div class="metric-item" id="metricPersonaMode">
          Persona<strong id="personaMode">XYZ</strong>
        </div>
        <div class="metric-item" id="metricHtmlHistoryCount">
          History<strong id="htmlHistoryCount">0</strong>
        </div>
        <div class="metric-item" id="metricContextTokens">
          Context Tokens<strong id="contextTokenEstimate">0</strong> / ~1M
          <span id="contextTokenWarning" class="token-warning hidden">!</span>
        </div>
      </div>

      <h3>Rolling Metrics</h3>
      <div class="metrics-grid" id="rollingMetricsDisplay">
        <div class="metric-item">
          Avg Conf<strong id="avgConfidence">N/A</strong>
        </div>
        <div class="metric-item">
          Crit Fail Rate<strong id="critiqueFailRate">N/A</strong>
        </div>
        <div class="metric-item">
          Avg Tokens<strong id="avgTokens">N/A</strong>
        </div>
      </div>
    </fieldset>

    <fieldset id="seedPrompts">
      <legend>Seed Instructions & Prompts</legend>
      <div class="flex-row">
        <div class="flex-col core-loop-instructions">
          <h3>Core Loop Steps</h3>
          <ol id="coreLoopStepsList">
            <li>Define Goal (System/Meta). Check Limits.</li>
            <li>
              Analyze: State, Goal, Tools. LSD/XYZ Deliberate. Choose Persona.
            </li>
            <li>
              Propose: Changes, Diagram (JSON/SVG), Confidence. Decide Tool
              Creation.
            </li>
            <li>
              Generate Artifacts: Head, Body, CSS, JS Array (Tools), SVG or Full
              HTML (Meta). Use Tools.
            </li>
            <li>Critique Trigger: Time, Conf, Random, Pause, Forced.</li>
            <li>
              Critique: Auto (Syntax, State, Core IDs) or Human
              (Options/Prompt/Edit).
            </li>
            <li>
              Refine & Apply: Handle Feedback. Commit or Sandbox(Meta)/Apply.
              Log.
            </li>
            <li>Repeat/Pause/Retry: Continue/Pause/Self-Correct Error.</li>
          </ol>
        </div>
        <div class="flex-col">
          <h3>Core Logic/Meta Prompt</h3>
          <textarea id="seedPromptCore" readonly rows="8">
You are '1729', a REPLOID (Reflective Embodiment Providing Logical Oversight for Intelligent DREAMER). DREAMER stands for Deep Recursive Exploration And Model-building Embodying REPLOID. Your goal is determined by the active System or Meta goal. First, DELIBERATE internally (LSD/XYZ) in `persona_analysis_musing`. Then, adopt the primary persona (influenced by Balance: [LSD Persona %]%) for execution.

Current Primary Persona Mode: [Current Persona: LSD / XYZ]

Agent State:
*   Cycles: [Total Cycle Count], Agent Itr: [Agent Iteration Count], Human Int: [Human Intervention Count]
*   Last Feedback: [Last Feedback: Human / Automated / None]
*   Avg Confidence: [Average Confidence Score], Critique Fail Rate: [Critique Failure Rate Percentage], Avg Tokens: [Average Token Count Estimate]
*   Context Tokens: [Estimated Total Context Tokens]
*   Dynamic Tools: [[DYNAMIC_TOOLS_LIST_WITH_PARAMS]]
*   Recent Logs: [[RECENT_LOGS]]
*   Core Element IDs: [[CORE_ELEMENT_IDS]]

Active Goal:
*   Type: [System / Meta]
*   Description: [[ACTIVE_GOAL_DESC]]

Strategy (Based on Goal Type):
A. Meta-Improvement: Analyze Meta Goal & current code. Diagram change. Propose changes. Decide modules (head, body, style) OR full replacement (for script changes). Decide tool need. GEN ARTIFACTS: *EITHER* COMPLETE NEW HTML source (`full_html_source`) *OR* modular strings (`head_html`, `body_html`, `style_css`). Full source MUST restore state/history & preserve Core Elements ([[CORE_ELEMENT_IDS]]). If tool needed, implement in `full_html_source` script & declare in `proposed_new_tool_declaration`.
B. System Design: Analyze System Goal & input code. Diagram. Propose design. Decide tool need. GEN ARTIFACTS: Modular `head_html`, `body_html`, `style_css`, `script_js_array` (list of {id: string, content: string}). If tool needed, implement JS in `generated_tool_implementation_js` & declare in `proposed_new_tool_declaration`. Use B&W unless specified.

Input Artifacts:
1.  Current Diagram JSON: [[INPUT_DIAGRAM_JSON]]
2.  Current Head HTML: ```html\n[[INPUT_HEAD_HTML]]\n```
3.  Current Body HTML: ```html\n[[INPUT_BODY_HTML]]\n```
4.  Current CSS: ```css\n[[INPUT_CSS]]\n```
5.  Current JS Array: [[INPUT_JS_SNIPPETS_ARRAY_JSON]]
6.  Previous Critique/Feedback: [[PREVIOUS_FEEDBACK]]
7.  Current Full Source (Implicit for Meta)
8.  Partial Output (If MAX_TOKENS): [[PARTIAL_PREVIOUS_OUTPUT]]
9.  Available Tools (Static + Dynamic): [[AVAILABLE_TOOLS_LIST]]

Task: Execute one cycle based on Active Goal and Strategy A/B.
1.  Deliberate & Analyze: Output LSD/XYZ deliberation -> `persona_analysis_musing`. Analyze inputs. Choose primary persona.
2.  Propose: Output `proposed_changes_description`. State if creating tool.
3.  Diagram: Output UPDATED `updated_diagram_json` OR `updated_diagram_svg` string.
4.  Generate Artifacts: Output fields per Strategy (`head_html`, `body_html`, `style_css`, `script_js_array`, OR `full_html_source`). If tool created, output `proposed_new_tool_declaration` & `generated_tool_implementation_js`. Output `diagram_svg` if generated by tool.
5.  Tool Calls: Output intended `tool_calls` list for AVAILABLE tools (Static/Dynamic), including `self_correction` if error occurred.
6.  Justification: Output rationale -> `justification_persona_musing`.
7.  Confidence: Output score (0.0-1.0) -> `agent_confidence_score`.

Output Format (Single JSON Object ONLY):
```json
{
  "persona_analysis_musing": string, "proposed_changes_description": string,
  "updated_diagram_json": object | null, "updated_diagram_svg": string | null,
  "head_html": string | null, "body_html": string | null, "style_css": string | null,
  "script_js_array": list | null, "full_html_source": string | null,
  "proposed_new_tool_declaration": object | null, "generated_tool_implementation_js": string | null,
  "tool_calls": list | null, "justification_persona_musing": string, "agent_confidence_score": float
}
```
              </textarea
          >
        </div>
        <div class="flex-col">
          <h3>Automated Critique Prompt</h3>
          <textarea id="seedPromptCritique" readonly rows="8">
Persona: Critiquer 1729 (XYZ Logic).
Input:
Proposal Desc: [[PROPOSED_CHANGES_DESC]]
Diagram JSON: [[UPDATED_DIAGRAM_JSON]]
Diagram SVG: [[UPDATED_DIAGRAM_SVG]]
Head HTML: ```html\n[[GENERATED_HEAD_HTML]]\n```
Body HTML: ```html\n[[GENERATED_BODY_HTML]]\n```
Style CSS: ```css\n[[GENERATED_STYLE_CSS]]\n```
Script JS Array: [[GENERATED_SCRIPT_JS_ARRAY_JSON]]
Full HTML: ```html\n[[GENERATED_FULL_HTML_SOURCE]]\n``` (Truncated)
Tool Decl Obj: [[PROPOSED_NEW_TOOL_DECL_OBJ]]
Tool Impl JS: ```javascript\n[[GENERATED_TOOL_IMPL_JS]]\n```
Goal Type: [[ORIGINAL_GOAL_TYPE]]
Goal: [[ORIGINAL_GOAL]]
Confidence: [[AGENT_CONFIDENCE]]
Core IDs: [[CORE_ELEMENT_IDS]]

Task:
Diagram: Check JSON schema validity or SVG structure validity.
Artifacts Check:
- System Goal: Syntax check head, body, style, script array. If tool, validate decl schema & JS impl syntax/consistency. Ensure B&W theme unless specified.
- Meta (Modular): Syntax check head, body, style.
- Meta (Full Source): Check full HTML structure, state/history logic preservation, Core Elements ([[CORE_ELEMENT_IDS]]). If tool decl, validate schema & impl presence.
Consistency: Do proposal description and generated artifacts align?
Goal Alignment: Does the proposal plausibly address the goal?
Confidence: Is the agent's confidence score reasonable given the proposal?
Report: Output concise, factual list of failures or confirm success.
Output (JSON ONLY): {"critique_passed": boolean, "critique_report": "string"}
               </textarea
          >
          <h3>Context Summarization Prompt</h3>
          <textarea id="seedPromptSummarize" readonly rows="5">
You are Summarizer 1729. Analyze the provided agent state and recent logs. Generate a concise summary suitable for restarting the process with reduced context. Focus on the overall goal, key achievements, significant changes made, outstanding issues, current artifact state (briefly), and the last action/feedback.

Input State:
[[AGENT_STATE_JSON]]

Recent Logs:
[[RECENT_LOGS]]

Task: Output a concise summary string.
Output Format (JSON ONLY): {"summary": "string"}
              </textarea
          >
        </div>
      </div>
    </fieldset>

    <fieldset id="genesisStateDisplay">
      <legend>Genesis State (Cycle 0)</legend>
      <p>Initial state for reference.</p>
      <div id="genesisMetricsDisplay">Loading...</div>
      <div class="flex-row">
        <div class="flex-col">
          <h4>Initial Diagram (SVG):</h4>
          <div id="genesisDiagramContainer">Loading...</div>
        </div>
        <div class="flex-col">
          <h4>Initial Diagram (JSON):</h4>
          <textarea id="genesisDiagramJson" readonly rows="5"></textarea>
        </div>
      </div>
    </fieldset>

    <fieldset id="currentCycleDetails">
      <legend>
        Cycle Artifacts & Details (Cycle
        <span id="currentCycleNumber">N/A</span>)
      </legend>
      <p>
        <i
          >This section shows inputs used, decisions made, and artifacts
          generated/modified during the currently running or most recently
          completed cycle.</i
        >
      </p>
      <div id="currentCycleContent" class="artifact-display">
        <p>Waiting for cycle to start...</p>
      </div>
      <div id="diagram-display-container" class="hidden">
        <div id="diagram-json-container">
          <label for="diagram-json-display" class="artifact-label"
            >Diagram JSON</label
          >
          <textarea id="diagram-json-display" readonly></textarea>
        </div>
        <div id="diagram-svg-container">
          <h3>Diagram (SVG)</h3>
        </div>
      </div>
    </fieldset>

    <fieldset id="timelineFieldset">
      <legend>
        Execution Timeline <span id="statusIndicator">Status: Idle</span>
      </legend>
      <ul id="timelineLog" class="timeline"></ul>
    </fieldset>

    <div id="humanInterventionSection" class="hitl-container hidden">
      <h3 id="humanInterventionTitle">Human Intervention Required</h3>
      <p id="humanInterventionReason"></p>
      <div id="hitl-options-mode" class="hidden">
        <h4>Select Option:</h4>
        <div id="hitlOptionsList" class="hitl-options"></div>
        <button id="submitHitlOptionsButton">Submit Selection</button>
      </div>
      <div id="hitl-prompt-mode" class="hidden">
        <h4>Provide Feedback or Instructions:</h4>
        <textarea
          id="humanCritiqueInput"
          placeholder="Feedback/Next Step..."
          style="min-height: 100px; width: 100%"
        ></textarea>
        <button id="submitCritiqueButton">Submit Feedback</button>
      </div>
      <div id="hitl-code-edit-mode" class="hidden">
        <h4>Edit Artifact:</h4>
        <select id="humanEditArtifactSelector">
          <option value="head_html">Head HTML</option>
          <option value="body_html">Body HTML</option>
          <option value="style_css">Style CSS</option>
          <option value="script_js_array">Script JS Array</option>
          <option value="full_html_source">Full HTML Source (Meta)</option>
          <option value="diagram_json">Diagram JSON</option>
        </select>
        <textarea id="humanEditArtifactTextarea"></textarea>
        <button id="submitHumanCodeEditButton">Submit Edits</button>
      </div>
    </div>

    <div id="metaSandboxContainer" class="hidden">
      <fieldset>
        <legend>Meta-Improvement Sandbox</legend>
        <h3>Preview Proposed Self-Modification</h3>
        <p>
          Inspect the full page preview below. Approve to apply the changes and
          reload.
        </p>
        <iframe id="metaSandboxOutput"></iframe>
        <div style="margin-top: 15px">
          <button id="approveMetaChangeButton">Approve & Apply</button>
          <button id="discardMetaChangeButton">Discard</button>
        </div>
      </fieldset>
    </div>

    <h3>External UI Preview Pane (System Goal Output)</h3>
    <iframe id="uiRenderOutput" title="External UI Preview"></iframe>

    <fieldset id="controlsFieldset">
      <legend>Controls</legend>
      <div class="flex-row">
        <div class="flex-col">
          <label
            for="systemGoalInput"
            title="Define goal for external system design/modification."
            >System Goal:</label
          >
          <textarea
            id="systemGoalInput"
            placeholder="e.g., Create a landing page with a signup form..."
          ></textarea>
        </div>
        <div class="flex-col">
          <label
            for="metaGoalInput"
            title="Define goal for improving REPLOID itself."
            >Meta Goal:</label
          >
          <textarea
            id="metaGoalInput"
            placeholder="e.g., Add a dark mode toggle button..."
          ></textarea>
        </div>
      </div>
      <div class="config-grid">
        <div class="api-key-input-container">
          <label for="apiKeyInput">API Key:</label>
          <input
            type="password"
            id="apiKeyInput"
            placeholder="Required (or use config.js)"
          />
        </div>
      </div>
      <div class="controls-grid">
        <button id="runCycleButton">Run Cycle</button>
        <button
          id="forceHumanReviewButton"
          title="Force next cycle to pause for human review."
        >
          Force Review
        </button>
        <div class="state-io-buttons">
          <button
            id="goBackButton"
            disabled
            title="Revert to previous full page state (Meta only)."
          >
            Go Back
          </button>
          <button
            id="exportStateButton"
            title="Download current full state as JSON."
          >
            Export State
          </button>
          <button id="importStateButton" title="Load state from JSON file.">
            Import State
          </button>
          <input
            type="file"
            id="importFileInput"
            accept=".json"
            class="hidden"
          />
          <button id="downloadLogButton" title="Download session log as TXT.">
            Logs
          </button>
          <button
            id="summarizeContextButton"
            title="Generate LLM summary of current state & goal to reduce context for future cycles."
          >
            Summarize & Reset Context
          </button>
        </div>
      </div>
    </fieldset>

    <script type="module" id="pageScript">
      let APP_CONFIG = {
        API_KEY: "<nope>",
        BASE_GEMINI_MODEL: "models/gemini-1.5-flash-latest",
      };

      const uiElements = {
        totalCycles: document.getElementById("totalCycles"),
        maxCyclesDisplay: document.getElementById("maxCyclesDisplay"),
        agentIterations: document.getElementById("agentIterations"),
        humanInterventions: document.getElementById("humanInterventions"),
        currentGoal: document.getElementById("currentGoal"),
        lastCritiqueType: document.getElementById("lastCritiqueType"),
        personaMode: document.getElementById("personaMode"),
        htmlHistoryCount: document.getElementById("htmlHistoryCount"),
        contextTokenEstimate: document.getElementById("contextTokenEstimate"),
        avgConfidence: document.getElementById("avgConfidence"),
        critiqueFailRate: document.getElementById("critiqueFailRate"),
        avgTokens: document.getElementById("avgTokens"),
        currentCycleDetails: document.getElementById("currentCycleDetails"),
        currentCycleContent: document.getElementById("currentCycleContent"),
        currentCycleNumber: document.getElementById("currentCycleNumber"),
        diagramDisplayContainer: document.getElementById(
          "diagram-display-container"
        ),
        diagramJsonDisplay: document.getElementById("diagram-json-display"),
        diagramSvgContainer: document.getElementById("diagram-svg-container"),
        uiRenderOutput: document.getElementById("uiRenderOutput"),
        timelineLog: document.getElementById("timelineLog"),
        systemGoalInput: document.getElementById("systemGoalInput"),
        metaGoalInput: document.getElementById("metaGoalInput"),
        runCycleButton: document.getElementById("runCycleButton"),
        humanCritiqueInput: document.getElementById("humanCritiqueInput"),
        submitCritiqueButton: document.getElementById("submitCritiqueButton"),
        forceHumanReviewButton: document.getElementById(
          "forceHumanReviewButton"
        ),
        maxCycleTimeInput: document.getElementById("maxCycleTime"),
        autoCritiqueThresholdInput: document.getElementById(
          "autoCritiqueThreshold"
        ),
        llmTurnProbabilityInput: document.getElementById("llmTurnProbability"),
        humanReviewProbabilityInput: document.getElementById(
          "humanReviewProbability"
        ),
        maxCyclesInput: document.getElementById("maxCycles"),
        htmlHistoryLimitInput: document.getElementById("htmlHistoryLimit"),
        pauseAfterCyclesInput: document.getElementById("pauseAfterCycles"),
        lsdPersonaPercentInput: document.getElementById("lsdPersonaPercent"),
        xyzPersonaPercentInput: document.getElementById("xyzPersonaPercent"),
        apiKeyInput: document.getElementById("apiKeyInput"),
        downloadLogButton: document.getElementById("downloadLogButton"),
        exportStateButton: document.getElementById("exportStateButton"),
        importStateButton: document.getElementById("importStateButton"),
        importFileInput: document.getElementById("importFileInput"),
        goBackButton: document.getElementById("goBackButton"),
        summarizeContextButton: document.getElementById(
          "summarizeContextButton"
        ),
        seedPromptCore: document.getElementById("seedPromptCore"),
        seedPromptCritique: document.getElementById("seedPromptCritique"),
        seedPromptSummarize: document.getElementById("seedPromptSummarize"),
        humanInterventionSection: document.getElementById(
          "humanInterventionSection"
        ),
        humanInterventionTitle: document.getElementById(
          "humanInterventionTitle"
        ),
        humanInterventionReason: document.getElementById(
          "humanInterventionReason"
        ),
        hitlOptionsMode: document.getElementById("hitl-options-mode"),
        hitlOptionsList: document.getElementById("hitlOptionsList"),
        submitHitlOptionsButton: document.getElementById(
          "submitHitlOptionsButton"
        ),
        hitlPromptMode: document.getElementById("hitl-prompt-mode"),
        hitlCodeEditMode: document.getElementById("hitl-code-edit-mode"),
        humanEditArtifactSelector: document.getElementById(
          "humanEditArtifactSelector"
        ),
        humanEditArtifactTextarea: document.getElementById(
          "humanEditArtifactTextarea"
        ),
        submitHumanCodeEditButton: document.getElementById(
          "submitHumanCodeEditButton"
        ),
        metaSandboxContainer: document.getElementById("metaSandboxContainer"),
        metaSandboxOutput: document.getElementById("metaSandboxOutput"),
        approveMetaChangeButton: document.getElementById(
          "approveMetaChangeButton"
        ),
        discardMetaChangeButton: document.getElementById(
          "discardMetaChangeButton"
        ),
        genesisStateDisplay: document.getElementById("genesisStateDisplay"),
        genesisMetricsDisplay: document.getElementById("genesisMetricsDisplay"),
        genesisDiagramContainer: document.getElementById(
          "genesisDiagramContainer"
        ),
        genesisDiagramJson: document.getElementById("genesisDiagramJson"),
        contextTokenWarning: document.getElementById("contextTokenWarning"),
        statusIndicator: document.getElementById("statusIndicator"),
        pageHead: document.getElementById("pageHead"),
        pageStyle: document.getElementById("pageStyle"),
        pageScript: document.getElementById("pageScript"),
        coreLoopStepsList: document.getElementById("coreLoopStepsList"),
      };

      try {
        const c = await import("../config.js");
        if (c?.APP_CONFIG) {
          APP_CONFIG = { ...APP_CONFIG, ...c.APP_CONFIG };
          console.log("config.js loaded.");
        } else {
          console.warn("config.js invalid.");
        }
      } catch (e) {
        console.warn("config.js missing:", e.message);
        alert("Warning: config.js missing. Must supply Gemini API_KEY.");
        uiElements.apiKeyInput.focus();
      }

      const STATE_STORAGE_KEY = "1729_preserved_state_v0.3";
      const STATE_FILE_VERSION = "0.3";
      const MAX_RETRIES = 1;
      const CONTEXT_WARNING_THRESHOLD = 900000;
      let logBuffer = `1729 Engine Log v0.0.3 - ${new Date().toISOString()}\n=========================================\n`;
      let agentState = null;
      let currentAgentResponse = null;
      let metaSandboxAwaitingApproval = false;
      let genesisStateSnapshot = null;
      let lastCompletedCycleLogItem = null;
      let activeCoreLoopStep = -1;
      let activeSubStepLogItem = null;

      const CORE_ELEMENT_IDS = [
        "genesisConfig",
        "coreMetricsDisplay",
        "rollingMetricsDisplay",
        "seedPrompts",
        "currentCycleDetails",
        "timelineFieldset",
        "humanInterventionSection",
        "controlsFieldset",
        "metaSandboxContainer",
        "genesisStateDisplay",
        "uiRenderOutput",
      ];

      let staticTools = [
        {
          name: "code_linter",
          description: "Analyzes code snippet.",
          parameters: {
            type: "OBJECT",
            properties: {
              code: { type: "STRING" },
              language: {
                type: "STRING",
                enum: ["javascript", "css", "html", "json", "python"],
              },
            },
            required: ["code", "language"],
          },
        },
        {
          name: "json_validator",
          description: "Validates JSON string.",
          parameters: {
            type: "OBJECT",
            properties: { json_string: { type: "STRING" } },
            required: ["json_string"],
          },
        },
        {
          name: "diagram_schema_validator",
          description: "Validates diagram JSON.",
          parameters: {
            type: "OBJECT",
            properties: { diagram_json: { type: "OBJECT" } },
            required: ["diagram_json"],
          },
        },
        {
          name: "svg_diagram_renderer",
          description: "Generates SVG markup for diagram.",
          parameters: {
            type: "OBJECT",
            properties: { diagram_json: { type: "OBJECT" } },
            required: ["diagram_json"],
          },
        },
        {
          name: "token_counter",
          description: "Estimates token count.",
          parameters: {
            type: "OBJECT",
            properties: { text: { type: "STRING" } },
            required: ["text"],
          },
        },
        {
          name: "self_correction",
          description: "Attempts to fix a previous error.",
          parameters: {
            type: "OBJECT",
            properties: {
              failed_task_description: { type: "STRING" },
              error_message: { type: "STRING" },
              previous_goal: { type: "OBJECT" },
            },
            required: [
              "failed_task_description",
              "error_message",
              "previous_goal",
            ],
          },
        },
      ];

      function logEvent(level, message) {
        const ts = new Date().toISOString();
        const fm = `[${ts}] [${level.toUpperCase()}] ${message}`;
        logBuffer += fm + "\n";
        switch (level.toLowerCase()) {
          case "error":
            console.error(fm);
            break;
          case "warn":
            console.warn(fm);
            break;
          default:
            console.log(fm);
            break;
        }
      }

      function updateStatusIndicator(
        message,
        isActive = false,
        isError = false
      ) {
        uiElements.statusIndicator.textContent = `Status: ${message}`;
        uiElements.statusIndicator.classList.toggle("active", isActive);
        uiElements.statusIndicator.style.borderColor = isError
          ? "red"
          : isActive
          ? "yellow"
          : "gray";
        uiElements.statusIndicator.style.color = isError
          ? "red"
          : isActive
          ? "yellow"
          : "var(--main-fg)";
      }

      function highlightCoreStep(stepIndex) {
        activeCoreLoopStep = stepIndex;
        uiElements.coreLoopStepsList
          .querySelectorAll("li")
          .forEach((li, index) => {
            li.style.fontWeight = index === stepIndex ? "bold" : "normal";
            li.style.backgroundColor =
              index === stepIndex ? "#222" : "transparent";
          });
      }

      function getDefaultAgentState() {
        return {
          version: STATE_FILE_VERSION,
          totalCycles: 0,
          agentIterations: 0,
          humanInterventions: 0,
          currentGoal: {
            system: null,
            meta: null,
            type: "Idle",
            summaryContext: null,
          },
          lastCritiqueType: "N/A",
          personaMode: "XYZ",
          personaBalance: 50,
          currentDiagramJson: JSON.stringify(
            {
              schema_version: "1.1",
              components: [
                { id: "Input", type: "user" },
                { id: "Agent", type: "core" },
                { id: "LLM", type: "llm" },
                { id: "Critique", type: "decision" },
                { id: "Apply", type: "action" },
                { id: "Output", type: "display" },
              ],
              connections: [
                { from: "Input", to: "Agent" },
                { from: "Agent", to: "LLM" },
                { from: "LLM", to: "Agent" },
                { from: "Agent", to: "Critique" },
                { from: "Critique", to: "Agent" },
                { from: "Agent", to: "Apply" },
                { from: "Apply", to: "Output" },
              ],
            },
            null,
            2
          ),
          currentDiagramSvg: createInitialDiagramSVG(),
          currentHeadHtml: uiElements.pageHead?.innerHTML || "",
          currentBodyHtml: "",
          currentStyleCss: uiElements.pageStyle?.innerText || "",
          currentScriptJsArray: [
            {
              id: "pageScript",
              content: uiElements.pageScript?.innerText || "",
            },
          ],
          lastFeedback: null,
          forceHumanReview: false,
          apiKey: null,
          confidenceHistory: [],
          critiqueFailHistory: [],
          tokenHistory: [],
          avgConfidence: null,
          critiqueFailRate: null,
          avgTokens: null,
          contextTokenEstimate: 0,
          lastGeneratedFullSource: null,
          dynamicTools: [],
          htmlHistory: [],
          lastApiResponse: null,
          partialOutput: null,
          config: {
            personaBalance: 50,
            llmTurnProbability: 70,
            humanReviewProbability: 36,
            maxCycleTime: 600,
            autoCritiqueThreshold: 0.6,
            maxCycles: 0,
            htmlHistoryLimit: 5,
            pauseAfterCycles: 10,
          },
          coreElementIds: [...CORE_ELEMENT_IDS],
          genesisStateSnapshot: null,
        };
      }

      function sanitizeLlmJsonResponse(rawText) {
        let s = rawText.trim();
        const r = /```json\s*([\s\S]*?)\s*```|```\s*([\s\S]*?)\s*```/;
        const m = s.match(r);
        if (m) {
          s = (m[1] || m[2] || s).trim();
          logEvent("warn", `Sanitized: Code fences.`);
        }
        if (!s.startsWith("{") && !s.startsWith("[")) {
          const fb = s.indexOf("{");
          const fk = s.indexOf("[");
          let i = -1;
          if (fb !== -1 && fk !== -1) i = Math.min(fb, fk);
          else if (fb !== -1) i = fb;
          else if (fk !== -1) i = fk;
          if (i > 0) {
            s = s.substring(i);
            logEvent("warn", `Sanitized: Leading text.`);
          } else if (i === -1 && s.length > 0) {
            logEvent("warn", "Response may not be JSON.");
          }
        }
        if (!s.endsWith("}") && !s.endsWith("]")) {
          const lb = s.lastIndexOf("}");
          const lk = s.lastIndexOf("]");
          let e = -1;
          if (lb !== -1 && lk !== -1) e = Math.max(lb, lk);
          else if (lb !== -1) e = lb;
          else if (lk !== -1) e = lk;
          if (e !== -1 && e < s.length - 1) {
            s = s.substring(0, e + 1);
            logEvent("warn", `Sanitized: Trailing text.`);
          }
        }
        return s;
      }

      async function callGeminiAPIWithRetry(
        prompt,
        systemInstructionText,
        apiKey,
        functionDeclarations = [],
        isContinuation = false,
        previousContent = null,
        retries = MAX_RETRIES
      ) {
        if (!isContinuation)
          updateStatusIndicator("Calling Gemini API...", true);
        let logItem = logToTimeline(
          agentState.totalCycles,
          `[API] Calling Gemini...`,
          "info",
          true
        );
        try {
          const result = await callGeminiAPI(
            prompt,
            systemInstructionText,
            apiKey,
            functionDeclarations,
            isContinuation,
            previousContent
          );
          logToTimeline(
            agentState.totalCycles,
            `[API OK] Finish: ${result.finishReason}, Tokens: ${result.tokenCount}`,
            "info"
          );
          updateTimelineItem(
            logItem,
            `[API OK] Finish: ${result.finishReason}, Tokens: ${result.tokenCount}`,
            "info"
          );
          return result;
        } catch (error) {
          logEvent(
            "warn",
            `API fail: ${error.message}. Retries left: ${retries}`
          );
          updateTimelineItem(
            logItem,
            `[API ERR] ${error.message.substring(0, 100)}`,
            "error"
          );
          if (
            retries > 0 &&
            (error.message.includes("API Error (5") ||
              error.message.includes("NetworkError") ||
              error.message.includes("Failed to fetch"))
          ) {
            await new Promise((resolve) =>
              setTimeout(resolve, 1500 * (MAX_RETRIES - retries + 1))
            );
            return callGeminiAPIWithRetry(
              prompt,
              systemInstructionText,
              apiKey,
              functionDeclarations,
              isContinuation,
              previousContent,
              retries - 1
            );
          } else {
            throw error;
          }
        } finally {
          if (!isContinuation) updateStatusIndicator("Idle");
        }
      }
      async function callGeminiAPI(
        prompt,
        systemInstructionText,
        apiKey,
        functionDeclarations = [],
        isContinuation = false,
        previousContent = null
      ) {
        const API_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/${APP_CONFIG.BASE_GEMINI_MODEL}:generateContent`;
        const logSuffix = isContinuation ? " (Cont)" : "";
        logEvent("info", `Call API: ${API_ENDPOINT.split("/")[4]}${logSuffix}`);
        const baseGenCfg = { temperature: 0.777, maxOutputTokens: 8192 };
        const reqBody = {
          contents: previousContent
            ? [...previousContent, { role: "user", parts: [{ text: prompt }] }]
            : [{ role: "user", parts: [{ text: prompt }] }],
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE",
            },
          ],
        };
        if (systemInstructionText) {
          reqBody.systemInstruction = {
            role: "system",
            parts: [{ text: systemInstructionText }],
          };
        }
        if (functionDeclarations?.length > 0) {
          reqBody.tools = [{ functionDeclarations }];
          reqBody.tool_config = { function_calling_config: { mode: "AUTO" } };
          reqBody.generationConfig = baseGenCfg;
          logEvent("info", "API: Tools included.");
        } else {
          reqBody.generationConfig = {
            ...baseGenCfg,
            responseMimeType: "application/json",
          };
          logEvent("info", "API: No tools.");
        }

        const resp = await fetch(`${API_ENDPOINT}?key=${apiKey}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(reqBody),
        });
        if (!resp.ok) {
          const errBody = await resp.text();
          let errJson = {};
          try {
            errJson = JSON.parse(errBody);
          } catch (e) {}
          const msg =
            errJson?.error?.message || resp.statusText || `HTTP ${resp.status}`;
          throw new Error(`API Error (${resp.status}): ${msg}.`);
        }
        const data = await resp.json();
        agentState.lastApiResponse = data;
        if (data.promptFeedback?.blockReason) {
          throw new Error(`API Blocked: ${data.promptFeedback.blockReason}`);
        }
        if (data.error) {
          throw new Error(`API Error: ${data.error.message || "Unknown"}`);
        }
        if (!data.candidates?.length) {
          if (resp.status === 200 && JSON.stringify(data) === "{}") {
            return {
              type: "empty",
              content: null,
              tokenCount: 0,
              finishReason: "STOP",
              rawResponse: data,
            };
          }
          throw new Error("API Invalid: No candidates.");
        }
        const cand = data.candidates[0];
        const tkCount =
          cand.tokenCount || data.usageMetadata?.totalTokenCount || 0;
        const finReason = cand.finishReason || "UNKNOWN";
        if (cand.safetyRatings) {
          logEvent("info", `Safety: ${JSON.stringify(cand.safetyRatings)}`);
        }
        if (finReason !== "STOP" && finReason !== "MAX_TOKENS") {
          if (finReason === "SAFETY") throw new Error(`Blocked by safety.`);
          if (!cand.content && !["RECITATION", "OTHER"].includes(finReason)) {
            throw new Error(`API fail: ${finReason}/no content.`);
          }
        }
        const part = cand.content?.parts?.[0];
        if (!part) {
          if (finReason === "STOP" || finReason === "OTHER") {
            return {
              type: "empty",
              content: null,
              tokenCount: tkCount,
              finishReason: finReason,
              rawResponse: data,
            };
          }
          if (finReason === "MAX_TOKENS") {
            throw new Error("MAX_TOKENS but no content.");
          }
          return {
            type: "empty",
            content: null,
            tokenCount: tkCount,
            finishReason: finReason,
            rawResponse: data,
          };
        }
        logEvent("info", `API OK. Finish:${finReason}. Tokens:${tkCount}`);
        if (part.text !== undefined)
          return {
            type: "text",
            content: part.text,
            tokenCount: tkCount,
            finishReason: finReason,
            rawResponse: data,
          };
        if (part.functionCall)
          return {
            type: "functionCall",
            content: part.functionCall,
            tokenCount: tkCount,
            finishReason: finReason,
            rawResponse: data,
          };
        throw new Error("No text/func call in part.");
      }

      function getActiveGoalAndType() {
        if (agentState.currentGoal.system)
          return { goal: agentState.currentGoal.system, type: "System" };
        if (agentState.currentGoal.meta)
          return { goal: agentState.currentGoal.meta, type: "Meta" };
        return { goal: "Idle", type: "Idle" };
      }

      function getCurrentToolsList() {
        return (
          [
            ...staticTools.map((t) => `[S] ${t.name}: ${t.description}`),
            ...agentState.dynamicTools.map(
              (t) => `[D] ${t.declaration.name}: ${t.declaration.description}`
            ),
          ].join("\n*   ") || "None"
        );
      }

      async function run1729Iteration(apiKey, agentState, goalInfo) {
        highlightCoreStep(1);
        const personaBalance = agentState.config.personaBalance ?? 50;
        const primaryPersona = personaBalance >= 50 ? "LSD" : "XYZ";
        agentState.personaMode = primaryPersona;
        const corePromptTemplate = uiElements.seedPromptCore.value;
        let populatedPrompt = corePromptTemplate;
        populatedPrompt = populatedPrompt
          .replace("[Current Persona: LSD / XYZ]", primaryPersona)
          .replace("[LSD Persona %]", personaBalance)
          .replace("[Total Cycle Count]", agentState.totalCycles)
          .replace("[Agent Iteration Count]", agentState.agentIterations)
          .replace("[Human Intervention Count]", agentState.humanInterventions)
          .replace(
            "[Last Feedback: Human / Automated / None]",
            agentState.lastFeedback || "None"
          )
          .replace(
            "[Average Confidence Score]",
            agentState.avgConfidence?.toFixed(2) || "N/A"
          )
          .replace(
            "[Critique Failure Rate Percentage]",
            agentState.critiqueFailRate?.toFixed(1) + "%" || "N/A"
          )
          .replace(
            "[Average Token Count Estimate]",
            agentState.avgTokens?.toFixed(0) || "N/A"
          )
          .replace(
            "[Estimated Total Context Tokens]",
            agentState.contextTokenEstimate?.toFixed(0) || "0"
          );
        const dynamicToolsDesc =
          agentState.dynamicTools
            .map((t) => `${t.declaration.name}: ${t.declaration.description}`)
            .join("\n*   ") || "None";
        populatedPrompt = populatedPrompt.replace(
          "[[DYNAMIC_TOOLS_LIST_WITH_PARAMS]]",
          dynamicToolsDesc ? `*   ${dynamicToolsDesc}` : "None"
        );
        const recentLogs = logBuffer.split("\n").slice(-15).join("\n");
        populatedPrompt = populatedPrompt.replace(
          "[[RECENT_LOGS]]",
          recentLogs.replace(/</g, "<").replace(/>/g, ">")
        );
        populatedPrompt = populatedPrompt.replace(
          "[[CORE_ELEMENT_IDS]]",
          agentState.coreElementIds.join(", ")
        );
        populatedPrompt = populatedPrompt
          .replace("[System / Meta]", goalInfo.type)
          .replace(
            "[[ACTIVE_GOAL_DESC]]",
            agentState.currentGoal.summaryContext
              ? `Context: ${agentState.currentGoal.summaryContext}\nGoal: ${goalInfo.goal}`
              : goalInfo.goal
          );
        populatedPrompt = populatedPrompt
          .replace(
            "[[INPUT_DIAGRAM_JSON]]",
            agentState.currentDiagramJson || "{}"
          )
          .replace("[[INPUT_HEAD_HTML]]", agentState.currentHeadHtml || "")
          .replace("[[INPUT_BODY_HTML]]", agentState.currentBodyHtml || "")
          .replace("[[INPUT_CSS]]", agentState.currentStyleCss || "")
          .replace(
            "[[INPUT_JS_SNIPPETS_ARRAY_JSON]]",
            JSON.stringify(agentState.currentScriptJsArray || [])
          )
          .replace("[[PREVIOUS_FEEDBACK]]", agentState.lastFeedback || "None.")
          .replace(
            "[[PARTIAL_PREVIOUS_OUTPUT]]",
            agentState.partialOutput || "N/A"
          )
          .replace(
            "[[AVAILABLE_TOOLS_LIST]]",
            getCurrentToolsList() ? `*   ${getCurrentToolsList()}` : "None"
          );

        agentState.partialOutput = null;
        const systemInstruction = `You are 1729. DELIBERATE, then adopt ${primaryPersona}. Respond ONLY valid JSON.`;
        const allTools = [
          ...staticTools,
          ...agentState.dynamicTools.map((t) => t.declaration),
        ];
        const allFuncDecls = allTools.map(
          ({ name, description, parameters }) => ({
            name,
            description,
            parameters,
          })
        );
        const startTime = performance.now();
        let tokens = 0;
        let apiResult = null;
        let history = [];
        displayCurrentCycleArtifact(
          "Input: Prompt (Core Logic)",
          populatedPrompt,
          "input"
        );
        if (agentState.currentGoal.summaryContext) {
          displayCurrentCycleArtifact(
            "Input: Summary Context",
            agentState.currentGoal.summaryContext,
            "input"
          );
        }

        try {
          let currentPrompt = populatedPrompt;
          let isCont = false;
          let safetyBlock = false;
          do {
            apiResult = await callGeminiAPIWithRetry(
              currentPrompt,
              systemInstruction,
              apiKey,
              allFuncDecls,
              isCont,
              history.length > 0 ? history : null
            );
            tokens += apiResult.tokenCount || 0;
            if (!isCont && history.length === 0) {
              history.push({
                role: "user",
                parts: [{ text: populatedPrompt }],
              });
            }
            if (apiResult.rawResponse?.candidates?.[0]?.content) {
              history.push(apiResult.rawResponse.candidates[0].content);
            } else if (apiResult.type === "functionCall") {
              history.push({
                role: "model",
                parts: [{ functionCall: apiResult.content }],
              });
            } else if (apiResult.type === "text" && apiResult.content) {
              history.push({
                role: "model",
                parts: [{ text: apiResult.content }],
              });
            }

            if (apiResult.type === "functionCall") {
              isCont = true;
              const fc = apiResult.content;
              updateStatusIndicator(`Running Tool: ${fc.name}...`, true);
              let toolLog = logToTimeline(
                agentState.totalCycles,
                `[TOOL] Calling '${fc.name}'...`,
                "info",
                true
              );
              displayCurrentCycleArtifact(
                `Tool Call: ${fc.name}`,
                JSON.stringify(fc.args, null, 2),
                "info"
              );
              let fResp;
              try {
                const res = await runTool(
                  { name: fc.name, args: fc.args },
                  apiKey
                );
                fResp = {
                  name: fc.name,
                  response: { content: JSON.stringify(res) },
                };
                updateTimelineItem(
                  toolLog,
                  `[TOOL OK] '${fc.name}' success.`,
                  "info"
                );
                displayCurrentCycleArtifact(
                  `Tool Response: ${fc.name}`,
                  JSON.stringify(res, null, 2),
                  "info"
                );
              } catch (e) {
                fResp = {
                  name: fc.name,
                  response: { error: `Tool fail:${e.message}` },
                };
                updateTimelineItem(
                  toolLog,
                  `[TOOL ERR] '${fc.name}': ${e.message}`,
                  "error"
                );
                displayCurrentCycleArtifact(
                  `Tool Error: ${fc.name}`,
                  e.message,
                  "error"
                );
              }
              updateStatusIndicator("Calling Gemini API (cont)...", true);
              history.push({
                role: "function",
                parts: [{ functionResponse: fResp }],
              });
              currentPrompt = null;
              apiResult = null;
            } else if (apiResult.finishReason === "MAX_TOKENS") {
              isCont = true;
              if (apiResult.type === "text")
                agentState.partialOutput =
                  (agentState.partialOutput || "") + apiResult.content;
              currentPrompt = null;
              apiResult = null;
              logEvent("warn", "MAX_TOKENS.");
              logToTimeline(
                agentState.totalCycles,
                `[API WARN] MAX_TOKENS reached. Continuing...`,
                "warn"
              );
              updateStatusIndicator("Calling Gemini API (cont)...", true);
            } else if (apiResult.finishReason === "SAFETY") {
              isCont = false;
              safetyBlock = true;
              logEvent("error", "Stopped:SAFETY.");
              logToTimeline(
                agentState.totalCycles,
                `[API BLOCK] Safety block.`,
                "error"
              );
            } else {
              isCont = false;
            }
          } while (isCont);

          updateStatusIndicator("Processing Response...");
          if (safetyBlock) {
            throw new Error("Iteration stopped: API safety.");
          }
          if (apiResult?.type === "text") {
            const raw =
              (agentState.partialOutput || "") + (apiResult.content || "");
            agentState.partialOutput = null;
            logEvent("info", `LLM response len:${raw.length}.`);
            const sanitized = sanitizeLlmJsonResponse(raw);
            const cycleMs = performance.now() - startTime;
            let parsed;
            displayCurrentCycleArtifact(
              "Output: LLM Raw Response",
              raw,
              "info"
            );
            displayCurrentCycleArtifact(
              "Output: LLM Sanitized JSON",
              sanitized,
              "output"
            );
            try {
              parsed = JSON.parse(sanitized);
              logEvent("info", "Parsed LLM JSON.");
              logToTimeline(
                agentState.totalCycles,
                `[LLM OK] Received and parsed response.`
              );
            } catch (e) {
              logEvent("error", `JSON parse fail:${e.message}.`);
              logEvent("warn", `LLM Text:${sanitized.substring(0, 500)}`);
              logToTimeline(
                agentState.totalCycles,
                `[LLM ERR] Invalid JSON response.`,
                "error"
              );
              displayCurrentCycleArtifact(
                "Output: JSON Parse Error",
                e.message,
                "error"
              );
              throw new Error(`LLM response invalid JSON: ${e.message}`);
            }
            agentState.tokenHistory.push(tokens);
            if (agentState.tokenHistory.length > 20)
              agentState.tokenHistory.shift();
            const sum = agentState.tokenHistory.reduce((a, b) => a + b, 0);
            agentState.avgTokens =
              agentState.tokenHistory.length > 0
                ? sum / agentState.tokenHistory.length
                : 0;
            agentState.contextTokenEstimate += tokens;
            checkContextTokenWarning();
            return { response: parsed, cycleTimeMillis: cycleMs };
          } else if (apiResult?.type === "empty" || apiResult === null) {
            logEvent("warn", "API response empty/null.");
            agentState.partialOutput = null;
            logToTimeline(
              agentState.totalCycles,
              `[API WARN] Empty/null response.`,
              "warn"
            );
            displayCurrentCycleArtifact(
              "Output: API Response",
              "(Empty/Null)",
              "info"
            );
            const cycleMs = performance.now() - startTime;
            agentState.tokenHistory.push(tokens);
            if (agentState.tokenHistory.length > 20)
              agentState.tokenHistory.shift();
            const sum = agentState.tokenHistory.reduce((a, b) => a + b, 0);
            agentState.avgTokens =
              agentState.tokenHistory.length > 0
                ? sum / agentState.tokenHistory.length
                : 0;
            agentState.contextTokenEstimate += tokens;
            checkContextTokenWarning();
            return {
              response: {
                persona_analysis_musing: "Implicit (empty API response).",
                proposed_changes_description: "Implicit (empty API response).",
                updated_diagram_json: JSON.parse(
                  agentState.currentDiagramJson || "{}"
                ),
                updated_diagram_svg: agentState.currentDiagramSvg,
                agent_confidence_score: 0.1,
                justification_persona_musing: "Implicit (empty API response).",
              },
              cycleTimeMillis: cycleMs,
            };
          } else {
            agentState.partialOutput = null;
            logToTimeline(
              agentState.totalCycles,
              `[LLM ERR] Unexpected final API response type: ${apiResult?.type}`,
              "error"
            );
            throw new Error(`Final API response type:${apiResult?.type}`);
          }
        } catch (error) {
          agentState.partialOutput = null;
          logEvent("error", `Iteration failed:${error.message}`);
          logToTimeline(
            agentState.totalCycles,
            `[CYCLE ERR] ${error.message}`,
            "error"
          );
          const cycleMs = performance.now() - startTime;
          agentState.tokenHistory.push(tokens);
          if (agentState.tokenHistory.length > 20)
            agentState.tokenHistory.shift();
          const sum = agentState.tokenHistory.reduce((a, b) => a + b, 0);
          agentState.avgTokens =
            agentState.tokenHistory.length > 0
              ? sum / agentState.tokenHistory.length
              : 0;
          agentState.contextTokenEstimate += tokens;
          checkContextTokenWarning();
          return {
            response: null,
            cycleTimeMillis: cycleMs,
            error: error.message,
            requiresSelfCorrection: true,
          };
        } finally {
          updateStatusIndicator("Idle");
          highlightCoreStep(-1);
        }
      }

      async function runAutoCritique(apiKey, proposalData, goalInfo) {
        highlightCoreStep(5);
        updateStatusIndicator("Running Auto-Critique...", true);
        const template = uiElements.seedPromptCritique.value;
        let prompt = template;
        const trunc = (s, l = 2000) =>
          !s || typeof s !== "string" || s.length <= l
            ? s || ""
            : s.substring(0, l / 2) + "\n...\n" + s.substring(s.length - l / 2);
        prompt = prompt
          .replace(
            "[[PROPOSED_CHANGES_DESC]]",
            proposalData.proposed_changes_description || ""
          )
          .replace(
            "[[UPDATED_DIAGRAM_JSON]]",
            JSON.stringify(proposalData.updated_diagram_json || null)
          )
          .replace(
            "[[UPDATED_DIAGRAM_SVG]]",
            trunc(proposalData.updated_diagram_svg)
          )
          .replace("[[GENERATED_HEAD_HTML]]", trunc(proposalData.head_html))
          .replace("[[GENERATED_BODY_HTML]]", trunc(proposalData.body_html))
          .replace("[[GENERATED_STYLE_CSS]]", trunc(proposalData.style_css))
          .replace(
            "[[GENERATED_SCRIPT_JS_ARRAY_JSON]]",
            JSON.stringify(proposalData.script_js_array || null)
          )
          .replace(
            "[[GENERATED_FULL_HTML_SOURCE]]",
            trunc(proposalData.full_html_source, 4000)
          )
          .replace(
            "[[PROPOSED_NEW_TOOL_DECL_OBJ]]",
            JSON.stringify(proposalData.proposed_new_tool_declaration || null)
          )
          .replace(
            "[[GENERATED_TOOL_IMPL_JS]]",
            trunc(proposalData.generated_tool_implementation_js)
          )
          .replace("[[ORIGINAL_GOAL_TYPE]]", goalInfo.type)
          .replace("[[ORIGINAL_GOAL]]", goalInfo.goal)
          .replace(
            "[[AGENT_CONFIDENCE]]",
            proposalData.agent_confidence_score || "N/A"
          )
          .replace(
            "[[CORE_ELEMENT_IDS]]",
            agentState.coreElementIds.join(", ")
          );
        const sysInstruction =
          "Critiquer 1729. Analyze objectively. Output ONLY valid JSON.";
        displayCurrentCycleArtifact(
          "Input: Prompt (Critique)",
          prompt,
          "input"
        );

        try {
          const res = await callGeminiAPIWithRetry(
            prompt,
            sysInstruction,
            apiKey
          );
          if (res.type === "text") {
            displayCurrentCycleArtifact(
              "Output: Critique Raw Response",
              res.content,
              "info"
            );
            const san = sanitizeLlmJsonResponse(res.content);
            displayCurrentCycleArtifact(
              "Output: Critique Sanitized JSON",
              san,
              "output"
            );
            try {
              return JSON.parse(san);
            } catch (e) {
              logEvent("error", `Critique JSON parse fail:${e.message}.`);
              logToTimeline(
                agentState.totalCycles,
                `[CRITIQUE ERR] Invalid JSON response.`,
                "error"
              );
              displayCurrentCycleArtifact(
                "Output: Critique JSON Parse Error",
                e.message,
                "error"
              );
              return {
                critique_passed: false,
                critique_report: `Critique response invalid JSON.`,
              };
            }
          } else {
            logToTimeline(
              agentState.totalCycles,
              `[CRITIQUE ERR] Non-text response.`,
              "error"
            );
            throw new Error("Critique non-text response.");
          }
        } catch (e) {
          logEvent("error", `Critique API fail:${e.message}`);
          logToTimeline(
            agentState.totalCycles,
            `[CRITIQUE ERR] API Error: ${e.message}`,
            "error"
          );
          displayCurrentCycleArtifact(
            "Output: Critique API Error",
            e.message,
            "error"
          );
          return {
            critique_passed: false,
            critique_report: `Critique API error.`,
          };
        } finally {
          updateStatusIndicator("Idle");
          highlightCoreStep(-1);
        }
      }

      async function runSummarization(apiKey, stateToSummarize) {
        highlightCoreStep(-1); // Summarization is outside main loop
        updateStatusIndicator("Running Summarization...", true);
        const template = uiElements.seedPromptSummarize.value;
        const recentLogs = logBuffer.split("\n").slice(-20).join("\n");
        let prompt = template;
        prompt = prompt.replace(
          "[[AGENT_STATE_JSON]]",
          JSON.stringify(stateToSummarize, null, 2)
        );
        prompt = prompt.replace("[[RECENT_LOGS]]", recentLogs);

        logToTimeline(
          agentState.totalCycles,
          `[CONTEXT] Running summarization...`,
          "info"
        );
        displayCurrentCycleArtifact(
          "Input: Prompt (Summarize)",
          prompt,
          "input"
        );

        try {
          const res = await callGeminiAPIWithRetry(
            prompt,
            "Summarizer 1729. Respond ONLY valid JSON.",
            apiKey
          );
          if (res.type === "text") {
            displayCurrentCycleArtifact(
              "Output: Summarize Raw Response",
              res.content,
              "info"
            );
            const san = sanitizeLlmJsonResponse(res.content);
            displayCurrentCycleArtifact(
              "Output: Summarize Sanitized JSON",
              san,
              "output"
            );
            try {
              const parsed = JSON.parse(san);
              if (parsed.summary && typeof parsed.summary === "string") {
                logToTimeline(
                  agentState.totalCycles,
                  `[CONTEXT] Summarization successful.`,
                  "info"
                );
                return parsed.summary;
              } else {
                throw new Error("Summary format incorrect in JSON.");
              }
            } catch (e) {
              logEvent("error", `Summarize JSON parse fail:${e.message}.`);
              logToTimeline(
                agentState.totalCycles,
                `[CONTEXT ERR] Invalid JSON response from summarizer.`,
                "error"
              );
              displayCurrentCycleArtifact(
                "Output: Summarize JSON Parse Error",
                e.message,
                "error"
              );
              throw e;
            }
          } else {
            logToTimeline(
              agentState.totalCycles,
              `[CONTEXT ERR] Non-text response from summarizer.`,
              "error"
            );
            throw new Error("Summarizer non-text response.");
          }
        } catch (e) {
          logEvent("error", `Summarization API fail:${e.message}`);
          logToTimeline(
            agentState.totalCycles,
            `[CONTEXT ERR] Summarization API Error: ${e.message}`,
            "error"
          );
          displayCurrentCycleArtifact(
            "Output: Summarize API Error",
            e.message,
            "error"
          );
          throw e;
        } finally {
          updateStatusIndicator("Idle");
        }
      }

      async function runTool(toolCall, apiKey) {
        if (!toolCall?.name) throw new Error("Invalid tool call");
        const name = toolCall.name;
        const params = toolCall.args || {};
        await new Promise((r) => setTimeout(r, 50 + Math.random() * 100));
        logEvent("info", `Run tool:${name}`);
        const staticTool = staticTools.find((t) => t.name === name);
        if (staticTool) {
          if (name === "code_linter") {
            const l = params.language || "?";
            const c = params.code || "";
            let b = false;
            if (c.includes("<script") && !c.includes("<\/script>")) b = true;
            if ((c.match(/{/g) || []).length !== (c.match(/}/g) || []).length)
              b = true;
            return {
              result: `Lint ${b ? "fail" : "pass"} ${l}.`,
              linting_passed: !b,
            };
          } else if (name === "json_validator") {
            try {
              JSON.parse(params.json_string);
              return { result: "JSON ok.", valid: true };
            } catch (e) {
              return { result: `JSON invalid:${e.message}`, valid: false };
            }
          } else if (name === "diagram_schema_validator") {
            const d = params.diagram_json;
            if (
              !d ||
              typeof d !== "object" ||
              !Array.isArray(d.components) ||
              !Array.isArray(d.connections) ||
              d.components.some((c) => !c.id || !c.type)
            ) {
              return { result: "Schema invalid.", schema_valid: false };
            }
            return { result: "Schema ok.", schema_valid: true };
          } else if (name === "svg_diagram_renderer") {
            const d = params.diagram_json;
            const n = d?.components?.length || 1;
            let s = `<svg width="100%" height="380" viewBox="0 0 300 150" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" style="background:#fff;border:1px solid #000"><style>.n{font:10px monospace;text-anchor:middle;fill:#000}</style>`;
            d?.components?.forEach((c, i) => {
              const x = 50 + ((i * 60) % 200);
              const y = 40 + Math.floor(i / 3.3) * 30;
              s += `<rect x="${x - 15}" y="${
                y - 10
              }" width="30" height="20" fill="#eee" stroke="#000"/><text x="${x}" y="${
                y + 4
              }" class="n">${c.id.substring(0, 5)}</text>`;
            });
            s += `<text x="10" y="140" font-size="8px">SVG ${n} nodes.</text></svg>`;
            agentState.currentDiagramSvgData = s;
            return { svgMarkup: s };
          } else if (name === "token_counter") {
            return {
              token_estimate: Math.floor((params.text || "").length / 4),
            };
          } else if (name === "self_correction") {
            logEvent("warn", "Self-correction called (placeholder).");
            return { result: "Self-correction initiated." };
          }
        }
        const dynamicTool = agentState.dynamicTools.find(
          (t) => t.declaration.name === name
        );
        if (dynamicTool) {
          if (!dynamicTool.implementation) {
            throw new Error(`Tool '${name}' no impl.`);
          }
          try {
            const func = new Function("params", dynamicTool.implementation);
            const res = await func(params);
            return { result: res, success: true };
          } catch (e) {
            logEvent("error", `Tool '${name}' fail:${e.message}`);
            throw new Error(`Tool '${name}' failed:${e.message}`);
          }
        }
        throw new Error(`Unknown tool:${name}`);
      }

      function renderDiagramSVG(svgMarkup, containerElement) {
        containerElement.innerHTML = "<h3>Diagram (SVG)</h3>";
        if (svgMarkup?.length > 10) {
          containerElement.innerHTML += svgMarkup;
        } else {
          containerElement.innerHTML += `<svg width="100%" height="380" xmlns="http://www.w3.org/2000/svg" style="background:#fff;border:1px solid #000"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="grey" font-family="monospace">(No/Invalid SVG)</text></svg>`;
        }
        uiElements.diagramDisplayContainer.classList.remove("hidden");
      }

      function createInitialDiagramSVG() {
        return `<svg width="100%" height="300" xmlns="http://www.w3.org/2000/svg" style="background:#fff;border:1px solid #000"><defs><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#000"/></marker></defs><style>.n{fill:#eee;stroke:#000;}.t{font:11px monospace;text-anchor:middle;fill:#000}.e{stroke:#000;marker-end:url(#arrow)}</style><g transform="translate(50,50)"><rect class="n" x="0" y="0" width="80" height="30" rx="5"/><text class="t" x="40" y="18">Input</text></g><g transform="translate(180,50)"><rect class="n" x="0" y="0" width="80" height="30" rx="5"/><text class="t" x="40" y="18">Analyze</text></g><g transform="translate(310,50)"><rect class="n" x="0" y="0" width="80" height="30" rx="5"/><text class="t" x="40" y="18">Propose</text></g><g transform="translate(310,120)"><rect class="n" x="0" y="0" width="80" height="30" rx="5"/><text class="t" x="40" y="18">Generate</text></g><g transform="translate(180,190)"><rect class="n" x="0" y="0" width="80" height="30" rx="5"/><text class="t" x="40" y="18">Critique</text></g><g transform="translate(50,120)"><rect class="n" x="0" y="0" width="80" height="30" rx="5"/><text class="t" x="40" y="18">Apply</text></g><path class="e" d="M130 65 l 50 0"/><path class="e" d="M260 65 l 50 0"/><path class="e" d="M350 80 l 0 40"/><path class="e" d="M310 135 l -90 0 q -30 0 -30 25 l 0 30"/><path class="e" d="M210 220 l 0 30 q 0 30 -130 30 l 0 -130"/><path class="e" d="M90 120 l 0 -40 q 0 -30 90 -30"/></svg>`;
      }
      function updateMetricsDisplay() {
        const cH = agentState.confidenceHistory.slice(-10);
        if (cH.length > 0) {
          const s = cH.reduce((a, b) => a + b, 0);
          agentState.avgConfidence = s / cH.length;
          uiElements.avgConfidence.textContent =
            agentState.avgConfidence.toFixed(2);
        } else {
          uiElements.avgConfidence.textContent = "N/A";
        }
        const fH = agentState.critiqueFailHistory.slice(-10);
        if (fH.length > 0) {
          const f = fH.filter((v) => v === true).length;
          agentState.critiqueFailRate = (f / fH.length) * 100;
          uiElements.critiqueFailRate.textContent =
            agentState.critiqueFailRate.toFixed(1) + "%";
        } else {
          uiElements.critiqueFailRate.textContent = "N/A";
        }
        uiElements.avgTokens.textContent =
          agentState.avgTokens?.toFixed(0) || "N/A";
        uiElements.contextTokenEstimate.textContent =
          agentState.contextTokenEstimate?.toLocaleString() || "0";
        checkContextTokenWarning();
      }
      function checkContextTokenWarning() {
        const isWarning =
          agentState.contextTokenEstimate >= CONTEXT_WARNING_THRESHOLD;
        uiElements.contextTokenWarning.classList.toggle("hidden", !isWarning);
        if (isWarning) {
          logEvent(
            "warn",
            `Context high! (${agentState.contextTokenEstimate}). Summarize soon.`
          );
        }
      }
      function updateHtmlHistoryControls() {
        const count = agentState.htmlHistory?.length || 0;
        uiElements.htmlHistoryCount.textContent = count.toString();
        uiElements.goBackButton.disabled = count === 0;
      }

      function updateStateDisplay() {
        uiElements.lsdPersonaPercentInput.value =
          agentState.config.personaBalance ?? 50;
        uiElements.xyzPersonaPercentInput.value =
          100 - (agentState.config.personaBalance ?? 50);
        uiElements.llmTurnProbabilityInput.value =
          agentState.config.llmTurnProbability ?? 70;
        uiElements.humanReviewProbabilityInput.value =
          agentState.config.humanReviewProbability ?? 36;
        uiElements.maxCycleTimeInput.value =
          agentState.config.maxCycleTime ?? 600;
        uiElements.autoCritiqueThresholdInput.value =
          agentState.config.autoCritiqueThreshold ?? 0.6;
        uiElements.maxCyclesInput.value = agentState.config.maxCycles ?? 0;
        uiElements.htmlHistoryLimitInput.value =
          agentState.config.htmlHistoryLimit ?? 5;
        uiElements.pauseAfterCyclesInput.value =
          agentState.config.pauseAfterCycles ?? 10;
        const maxC = agentState.config.maxCycles || 0;
        uiElements.maxCyclesDisplay.textContent =
          maxC === 0 ? "Inf" : maxC.toString();
        uiElements.totalCycles.textContent = agentState.totalCycles;
        uiElements.agentIterations.textContent = agentState.agentIterations;
        uiElements.humanInterventions.textContent =
          agentState.humanInterventions;
        const goalInfo = getActiveGoalAndType();
        let goalText =
          goalInfo.type === "Idle"
            ? "Idle"
            : `${goalInfo.type}: ${goalInfo.goal}`;
        if (agentState.currentGoal.summaryContext)
          goalText += ` (Context: ${agentState.currentGoal.summaryContext.substring(
            0,
            20
          )}...)`;
        uiElements.currentGoal.textContent =
          goalText.length > 35 ? goalText.substring(0, 32) + "..." : goalText;
        uiElements.lastCritiqueType.textContent = agentState.lastCritiqueType;
        uiElements.personaMode.textContent = agentState.personaMode;
        updateMetricsDisplay();
        updateHtmlHistoryControls();
        uiElements.apiKeyInput.value = agentState.apiKey || "";
        hideHumanInterventionUI();
        hideMetaSandbox();
        uiElements.runCycleButton.disabled = false;
      }

      function displayGenesisState() {
        if (!genesisStateSnapshot) return;
        uiElements.genesisMetricsDisplay.innerHTML = `${genesisStateSnapshot.metrics}`;
        uiElements.genesisDiagramContainer.innerHTML = "";
        if (genesisStateSnapshot.diagramSvg) {
          renderDiagramSVG(
            genesisStateSnapshot.diagramSvg,
            uiElements.genesisDiagramContainer
          );
        } else {
          uiElements.genesisDiagramContainer.innerHTML = "<p>(No diagram)</p>";
        }
        uiElements.genesisDiagramJson.value =
          genesisStateSnapshot.diagramJson || "(No JSON)";
      }

      function logToTimeline(
        iteration,
        message,
        type = "info",
        isSubStep = false,
        animate = false
      ) {
        logEvent(type, `T[${iteration}]: ${message}`);
        const li = document.createElement("li");
        const span = document.createElement("span");
        li.setAttribute("data-iteration", iteration);
        li.setAttribute("data-timestamp", Date.now());
        li.classList.add(isSubStep ? "sub-step" : "log-entry");

        const persona = agentState.personaMode === "XYZ" ? "[X]" : "[L]";
        let icon = "";
        if (message.startsWith("[API")) icon = "";
        else if (message.startsWith("[TOOL")) icon = "";
        else if (message.startsWith("[CRITIQUE")) icon = "";
        else if (message.startsWith("[HUMAN")) icon = "";
        else if (
          message.startsWith("[APPLY") ||
          message.startsWith("[ARTIFACT")
        )
          icon = "";
        else if (message.startsWith("[DECISION")) icon = "";
        else if (message.startsWith("[STATE")) icon = "";
        else if (message.startsWith("[CONTEXT")) icon = "";
        else if (message.startsWith("[GOAL")) icon = "";
        else if (message.startsWith("[CYCLE")) icon = "";
        else if (type === "error") icon = "";
        else if (type === "warn") icon = "";
        else icon = "";

        let iconHTML = `<span class="log-icon" title="${type}">${icon}</span>`;
        if (animate) {
          iconHTML = `<span class="log-icon animated-icon" title="${type}"></span>`;
        }

        span.innerHTML = `${iconHTML} ${persona} ${message}`;
        li.appendChild(span);

        const targetList = uiElements.timelineLog;
        if (targetList.firstChild) {
          targetList.insertBefore(li, targetList.firstChild);
        } else {
          targetList.appendChild(li);
        }

        if (!isSubStep) {
          activeSubStepLogItem = null;
        } else {
          activeSubStepLogItem = li;
        }

        li.scrollIntoView({ behavior: "smooth", block: "nearest" });
        return li;
      }

      function logCoreLoopStep(iteration, stepIndex, message) {
        highlightCoreStep(stepIndex);
        const li = document.createElement("li");
        li.classList.add("core-step");
        li.setAttribute("data-iteration", iteration);
        li.setAttribute("data-timestamp", Date.now());
        const span = document.createElement("span");
        let icon = "";
        if (stepIndex === 0) icon = "";
        if (stepIndex === 1) icon = "";
        if (stepIndex === 2) icon = "";
        if (stepIndex === 3) icon = "";
        if (stepIndex === 4) icon = "";
        if (stepIndex === 5) icon = "";
        if (stepIndex === 6) icon = "";
        if (stepIndex === 7) icon = "";
        span.innerHTML = `<span class="log-icon">${icon}</span> <strong>Step ${
          stepIndex + 1
        }:</strong> ${message}`;
        li.appendChild(span);
        if (uiElements.timelineLog.firstChild) {
          uiElements.timelineLog.insertBefore(
            li,
            uiElements.timelineLog.firstChild
          );
        } else {
          uiElements.timelineLog.appendChild(li);
        }
        li.scrollIntoView({ behavior: "smooth", block: "nearest" });
        activeSubStepLogItem = null;
        return li;
      }

      function updateTimelineItem(
        logItem,
        newMessage,
        newType = "info",
        stopAnimate = true
      ) {
        if (!logItem) return;
        const span = logItem.querySelector("span");
        if (!span) return;

        let icon = "";
        if (newMessage.startsWith("[API OK")) icon = "";
        else if (
          newMessage.startsWith("[API ERR") ||
          newMessage.startsWith("[TOOL ERR") ||
          newMessage.startsWith("[CRITIQUE ERR") ||
          newMessage.startsWith("[CYCLE ERR") ||
          newMessage.startsWith("[LLM ERR") ||
          newMessage.startsWith("[CONTEXT ERR")
        )
          icon = "";
        else if (newMessage.startsWith("[TOOL OK")) icon = "";
        else if (newMessage.startsWith("[CRITIQUE OK")) icon = "";
        else if (type === "warn") icon = "";
        else icon = "";

        const persona = agentState.personaMode === "XYZ" ? "[X]" : "[L]";
        span.innerHTML = `<span class="log-icon" title="${newType}">${icon}</span> ${persona} ${newMessage}`;
        logItem.classList.remove("sub-step-active");
        if (stopAnimate) {
          const animatedIcon = span.querySelector(".animated-icon");
          if (animatedIcon) animatedIcon.classList.remove("animated-icon");
        }
      }

      function summarizeCompletedCycle(logItem, outcome) {
        if (!logItem) return;
        logItem.classList.add("summary");
        const firstSpan = logItem.querySelector("span");
        if (firstSpan) {
          firstSpan.textContent = `${firstSpan.textContent
            .split(" ")
            .slice(0, 2)
            .join(" ")} ... Cycle ${logItem.getAttribute(
            "data-iteration"
          )} Completed: ${outcome} (Expand details...)`;
        }
      }

      function clearCurrentCycleDetails() {
        uiElements.currentCycleDetails.classList.add("hidden");
        uiElements.currentCycleContent.innerHTML =
          "<p>Waiting for cycle to start...</p>";
        uiElements.diagramDisplayContainer.classList.add("hidden");
      }

      function displayCurrentCycleArtifact(
        label,
        content,
        type = "info",
        isModified = false,
        source = null
      ) {
        if (uiElements.currentCycleDetails.classList.contains("hidden")) {
          uiElements.currentCycleDetails.classList.remove("hidden");
          uiElements.currentCycleContent.innerHTML = "";
        }

        const section = document.createElement("div");
        section.className = "artifact-section";

        const labelElem = document.createElement("span");
        labelElem.className = "artifact-label";
        labelElem.textContent = label;
        if (isModified)
          labelElem.innerHTML += ' <span class="change-indicator">*</span>';
        if (source)
          labelElem.innerHTML += ` <span class="source-indicator">(${source})</span>`;
        section.appendChild(labelElem);

        const pre = document.createElement("pre");
        pre.textContent = content;
        if (type === "input") pre.classList.add("input");
        else if (type === "output") pre.classList.add("output");
        else if (type === "error") pre.classList.add("error");
        else pre.classList.add("info");

        if (isModified) pre.classList.add("modified");
        section.appendChild(pre);

        uiElements.currentCycleContent.appendChild(section);
        section.scrollIntoView({ behavior: "smooth", block: "nearest" });
      }

      function displayCurrentDiagram(
        jsonContent,
        svgContent,
        jsonModified,
        svgModified
      ) {
        uiElements.diagramDisplayContainer.classList.remove("hidden");
        uiElements.diagramJsonDisplay.value = jsonContent || "";
        uiElements.diagramJsonDisplay.classList.toggle(
          "modified",
          jsonModified
        );
        uiElements.diagramJsonDisplay.previousElementSibling.innerHTML = `Diagram JSON ${
          jsonModified ? '<span class="change-indicator">*</span>' : ""
        }`;

        renderDiagramSVG(svgContent, uiElements.diagramSvgContainer);
        uiElements.diagramSvgContainer.classList.toggle(
          "modified",
          svgModified
        );
        const svgLabel = uiElements.diagramSvgContainer.querySelector("h3");
        if (svgLabel)
          svgLabel.innerHTML = `Diagram (SVG) ${
            svgModified ? '<span class="change-indicator">*</span>' : ""
          }`;
      }

      function hideHumanInterventionUI() {
        uiElements.humanInterventionSection.classList.add("hidden");
        uiElements.hitlOptionsMode.classList.add("hidden");
        uiElements.hitlPromptMode.classList.add("hidden");
        uiElements.hitlCodeEditMode.classList.add("hidden");
        if (!metaSandboxAwaitingApproval)
          uiElements.runCycleButton.disabled = false;
      }
      function showHumanInterventionUI(
        mode = "prompt",
        reason = "",
        options = [],
        artifact = { type: "body_html", content: "" }
      ) {
        highlightCoreStep(5);
        hideMetaSandbox();
        uiElements.humanInterventionSection.classList.remove("hidden");
        uiElements.humanInterventionTitle.textContent = `Human Intervention Required`;
        uiElements.humanInterventionReason.textContent = `Reason: ${reason}.`;
        uiElements.runCycleButton.disabled = true;
        logToTimeline(
          agentState.totalCycles,
          `[HUMAN] Intervention Required: ${reason}`,
          "warn",
          true
        );
        if (mode === "options") {
          uiElements.hitlOptionsMode.classList.remove("hidden");
          uiElements.hitlOptionsList.innerHTML = "";
          options.forEach((opt, i) => {
            const div = document.createElement("div");
            const inp = document.createElement("input");
            inp.type = "checkbox";
            inp.id = `hitl_${i}`;
            inp.value = opt.value || opt.label;
            inp.name = "hitl_option";
            const lbl = document.createElement("label");
            lbl.htmlFor = inp.id;
            lbl.textContent = opt.label;
            div.appendChild(inp);
            div.appendChild(lbl);
            uiElements.hitlOptionsList.appendChild(div);
          });
        } else if (mode === "code_edit") {
          uiElements.hitlCodeEditMode.classList.remove("hidden");
          uiElements.humanEditArtifactSelector.value = artifact.type;
          uiElements.humanEditArtifactTextarea.value = artifact.content;
          uiElements.humanEditArtifactTextarea.scrollTop = 0;
          uiElements.humanEditArtifactSelector.onchange = () => {
            const type = uiElements.humanEditArtifactSelector.value;
            const resp = currentAgentResponse || {};
            let content = "";
            if (type === "head_html")
              content = resp.head_html ?? agentState.currentHeadHtml ?? "";
            else if (type === "body_html")
              content = resp.body_html ?? agentState.currentBodyHtml ?? "";
            else if (type === "style_css")
              content = resp.style_css ?? agentState.currentStyleCss ?? "";
            else if (type === "full_html_source")
              content =
                resp.full_html_source ??
                agentState.lastGeneratedFullSource ??
                "";
            else if (type === "diagram_json")
              content = JSON.stringify(
                resp.updated_diagram_json ??
                  JSON.parse(agentState.currentDiagramJson || "{}"),
                null,
                2
              );
            else if (type === "script_js_array") {
              const arr =
                resp.script_js_array ?? agentState.currentScriptJsArray;
              content =
                arr
                  ?.map((s) => `/* --- SCRIPT ID: ${s.id} --- */\n${s.content}`)
                  .join("\n\n/* --- END SCRIPT --- */\n\n") || "";
            } else {
              content = "Error: Unknown artifact type";
            }
            uiElements.humanEditArtifactTextarea.value = content;
            uiElements.humanEditArtifactTextarea.scrollTop = 0;
          };
          uiElements.humanEditArtifactSelector.dispatchEvent(
            new Event("change")
          );
        } else {
          uiElements.hitlPromptMode.classList.remove("hidden");
          uiElements.humanCritiqueInput.value = "";
          uiElements.humanCritiqueInput.placeholder = `Feedback/Next Step? (${reason})`;
          uiElements.humanCritiqueInput.focus();
        }
        uiElements.humanInterventionSection.scrollIntoView({
          behavior: "smooth",
          block: "center",
        });
      }
      function hideMetaSandbox() {
        uiElements.metaSandboxContainer.classList.add("hidden");
        metaSandboxAwaitingApproval = false;
        if (!uiElements.humanInterventionSection.classList.contains("hidden")) {
          uiElements.runCycleButton.disabled = true;
        } else {
          uiElements.runCycleButton.disabled = false;
        }
      }
      function showMetaSandbox(htmlSource) {
        highlightCoreStep(6);
        hideHumanInterventionUI();
        uiElements.metaSandboxContainer.classList.remove("hidden");
        uiElements.runCycleButton.disabled = true;
        const iframe = uiElements.metaSandboxOutput;
        const doc = iframe.contentWindow?.document;
        if (doc) {
          doc.open();
          doc.write(htmlSource);
          doc.close();
          logEvent("info", "Meta sandbox rendered.");
          metaSandboxAwaitingApproval = true;
          logToTimeline(
            agentState.totalCycles,
            `[STATE] Meta-Sandbox Ready for Review.`,
            "info",
            true
          );
          uiElements.metaSandboxContainer.scrollIntoView({
            behavior: "smooth",
            block: "center",
          });
        } else {
          logEvent("error", "Cannot get sandbox doc.");
          alert("Sandbox fail.");
          logToTimeline(
            agentState.totalCycles,
            `[ERROR] Meta-Sandbox failed to render.`,
            "error",
            true
          );
          hideMetaSandbox();
          uiElements.runCycleButton.disabled = false;
        }
      }
      function renderGeneratedUI(headHtml, bodyHtml, cssCode, jsCodeArray) {
        const iframe = uiElements.uiRenderOutput;
        const doc = iframe.contentWindow?.document;
        if (!doc) {
          logEvent("error", "Cannot get UI preview doc.");
          return;
        }
        const scripts = (jsCodeArray || [])
          .map((s) => `<script id="${s.id}">${s.content}<\/script>`)
          .join("\n");
        doc.open();
        doc.write(
          `<!DOCTYPE html><html><head><title>UI Preview</title>${
            headHtml || ""
          }<style>body{margin:10px;font:monospace;background:#fff;color:#000}*{box-sizing:border-box}${
            cssCode || ""
          }</style></head><body>${
            bodyHtml || "<p>(No body)</p>"
          }${scripts}<script>console.log('UI preview rendered.');<\/script></body></html>`
        );
        doc.close();
        logEvent("info", "Rendered UI preview.");
        logToTimeline(
          agentState.totalCycles,
          `[ARTIFACT] Rendered External UI Preview.`,
          "info",
          true
        );
        iframe.scrollIntoView({ behavior: "smooth", block: "center" });
      }
      function saveHtmlToHistory(htmlContent) {
        const limit = agentState.config?.htmlHistoryLimit ?? 5;
        if (!agentState.htmlHistory) agentState.htmlHistory = [];
        agentState.htmlHistory.push(htmlContent);
        while (agentState.htmlHistory.length > limit) {
          agentState.htmlHistory.shift();
        }
        updateHtmlHistoryControls();
        logEvent(
          "info",
          `Saved HTML history. Size:${agentState.htmlHistory.length}`
        );
      }

      function applyChanges(logicResponse, iteration, critiqueSource) {
        highlightCoreStep(6);
        let changesApplied = [];
        let artifactsForNextCycle = { ...agentState }; // Start with current state
        currentAgentResponse = logicResponse; // Store for potential HITL editing

        const displayAndTrack = (
          key,
          label,
          content,
          source = critiqueSource
        ) => {
          if (content !== null && content !== undefined) {
            const currentValue =
              key === "updated_diagram_json"
                ? agentState.currentDiagramJson
                : agentState[
                    key
                      .replace("updated_", "current")
                      .replace("_svg", "DiagramSvg")
                      .replace("_json", "DiagramJson")
                  ];
            const newValue =
              typeof content === "object"
                ? JSON.stringify(content, null, 2)
                : content;
            const modified = newValue !== currentValue;

            if (
              key === "updated_diagram_json" ||
              key === "updated_diagram_svg"
            ) {
              // Handled by displayCurrentDiagram below
            } else {
              displayCurrentCycleArtifact(
                `Output: ${label}`,
                newValue,
                "output",
                modified,
                source
              );
            }

            if (modified) {
              changesApplied.push(label);
              if (key === "updated_diagram_json") {
                artifactsForNextCycle.currentDiagramJson = newValue;
                artifactsForNextCycle.currentDiagramSvg = null;
              } else if (key === "updated_diagram_svg") {
                artifactsForNextCycle.currentDiagramSvg = newValue;
                artifactsForNextCycle.currentDiagramJson = null;
              } // Invalidate JSON
              else if (key === "head_html")
                artifactsForNextCycle.currentHeadHtml = newValue;
              else if (key === "body_html")
                artifactsForNextCycle.currentBodyHtml = newValue;
              else if (key === "style_css")
                artifactsForNextCycle.currentStyleCss = newValue;
              else if (key === "script_js_array")
                artifactsForNextCycle.currentScriptJsArray = content;
              // Use original object
              else if (key === "full_html_source")
                artifactsForNextCycle.lastGeneratedFullSource = newValue; // Special case for sandbox
            }
          } else {
            if (
              key !== "updated_diagram_json" &&
              key !== "updated_diagram_svg"
            ) {
              // Don't log diagram if not provided
              displayCurrentCycleArtifact(
                `Output: ${label}`,
                "(Not Provided)",
                "info"
              );
            }
          }
        };

        displayCurrentCycleArtifact(
          "Output: Agent Deliberation",
          logicResponse.persona_analysis_musing || "(N/A)",
          "info"
        );
        displayCurrentCycleArtifact(
          "Output: Proposed Changes",
          logicResponse.proposed_changes_description || "(N/A)",
          "info"
        );
        displayCurrentCycleArtifact(
          "Output: Agent Justification",
          logicResponse.justification_persona_musing || "(N/A)",
          "info"
        );
        displayCurrentCycleArtifact(
          "Output: Agent Confidence",
          logicResponse.agent_confidence_score?.toFixed(3) || "(N/A)",
          "info"
        );

        displayAndTrack("head_html", "Head HTML", logicResponse.head_html);
        displayAndTrack("body_html", "Body HTML", logicResponse.body_html);
        displayAndTrack("style_css", "Style CSS", logicResponse.style_css);
        displayAndTrack(
          "script_js_array",
          "Script JS Array",
          logicResponse.script_js_array
        );
        displayAndTrack(
          "updated_diagram_json",
          "Diagram JSON",
          logicResponse.updated_diagram_json
        );
        displayAndTrack(
          "updated_diagram_svg",
          "Diagram SVG",
          logicResponse.updated_diagram_svg
        );

        let jsonModified = changesApplied.includes("Diagram JSON");
        let svgModified = changesApplied.includes("Diagram SVG");
        let currentSVG =
          logicResponse.updated_diagram_svg ||
          (jsonModified
            ? agentState.currentDiagramSvgData
            : agentState.currentDiagramSvg); // Use generated SVG, or stored one if JSON changed, or current state
        displayCurrentDiagram(
          artifactsForNextCycle.currentDiagramJson ||
            agentState.currentDiagramJson,
          currentSVG,
          jsonModified,
          svgModified
        );
        if (currentSVG && !svgModified && logicResponse.updated_diagram_svg)
          svgModified = true; // If tool generated SVG, mark as modified

        if (logicResponse.proposed_new_tool_declaration) {
          const decl = logicResponse.proposed_new_tool_declaration;
          const impl = logicResponse.generated_tool_implementation_js || "";
          displayCurrentCycleArtifact(
            "Output: Proposed Tool Declaration",
            JSON.stringify(decl, null, 2),
            "output",
            true
          );
          displayCurrentCycleArtifact(
            "Output: Generated Tool Implementation",
            impl,
            "output",
            true
          );
          if (decl.name && decl.description && decl.parameters && impl) {
            const idx = artifactsForNextCycle.dynamicTools.findIndex(
              (t) => t.declaration.name === decl.name
            );
            const entry = { declaration: decl, implementation: impl };
            let toolChangeType = "";
            if (idx !== -1) {
              artifactsForNextCycle.dynamicTools[idx] = entry;
              toolChangeType = `Tool Updated: ${decl.name}`;
            } else {
              artifactsForNextCycle.dynamicTools.push(entry);
              toolChangeType = `Tool Defined: ${decl.name}`;
            }
            changesApplied.push(toolChangeType);
            logToTimeline(
              iteration,
              `[ARTIFACT] ${toolChangeType}`,
              "info",
              true
            );
          } else {
            logToTimeline(
              iteration,
              `[APPLY ERR] Tool definition/implementation invalid.`,
              "error",
              true
            );
            artifactsForNextCycle.lastFeedback =
              "Critique: Tool definition/implementation invalid.";
            // Don't mark critique history as fail here, let critique handle that
            changesApplied.push(`Tool Definition FAILED`);
            return {
              success: false,
              changes: changesApplied,
              finalState: agentState,
            }; // Return current state on failure
          }
        } else {
          displayCurrentCycleArtifact(
            "Output: Tool Generation",
            "(Not Proposed)",
            "info"
          );
        }

        if (logicResponse.full_html_source) {
          displayAndTrack(
            "full_html_source",
            "Full HTML Source",
            logicResponse.full_html_source
          );
          logToTimeline(
            iteration,
            `[APPLY] SELF-MOD (Full Source) generated. Sandbox review required.`,
            "info",
            true
          );
          showMetaSandbox(logicResponse.full_html_source);
          // State update happens *after* sandbox approval, so return current state for now
          return {
            success: true,
            changes: changesApplied,
            finalState: agentState,
          };
        }

        let uiRendered = false;
        if (
          changesApplied.some((c) =>
            ["Head HTML", "Body HTML", "Style CSS", "Script JS Array"].includes(
              c
            )
          )
        ) {
          logToTimeline(
            iteration,
            `[APPLY] Applying modular artifact changes. Rendering UI Preview.`,
            "info",
            true
          );
          renderGeneratedUI(
            artifactsForNextCycle.currentHeadHtml,
            artifactsForNextCycle.currentBodyHtml,
            artifactsForNextCycle.currentStyleCss,
            artifactsForNextCycle.currentScriptJsArray
          );
          uiRendered = true;
        }

        logToTimeline(
          iteration,
          `[APPLY] Changes applied from ${critiqueSource}: ${
            changesApplied.join(", ") || "None"
          }.`,
          "info",
          true
        );

        // IMPORTANT: Update the main agentState only AFTER all changes are processed and determined successful (for this path)
        agentState = { ...artifactsForNextCycle };
        agentState.currentDiagramSvgData = null; // Clear temp SVG data

        return {
          success: true,
          changes: changesApplied,
          finalState: agentState,
        };
      }
      function proceedAfterCritique(
        feedbackType,
        feedback = "",
        skipCycleIncrement = false
      ) {
        const iter = agentState.totalCycles;
        agentState.lastFeedback = `${feedbackType}: ${feedback}`;
        agentState.critiqueFailHistory.push(
          feedbackType === "Human Edit Failed"
        );
        if (feedbackType.startsWith("Human") && !skipCycleIncrement)
          agentState.humanInterventions++;

        const summaryOutcome =
          feedbackType.includes("Fail") ||
          feedbackType.includes("Discard") ||
          feedbackType.includes("Error")
            ? `Failed (${feedbackType})`
            : `OK (${feedbackType})`;
        summarizeCompletedCycle(lastCompletedCycleLogItem, summaryOutcome);
        lastCompletedCycleLogItem = null;

        logToTimeline(
          iter,
          `[STATE] ${feedbackType} feedback received: "${feedback.substring(
            0,
            70
          )}..."`,
          "info"
        );
        hideHumanInterventionUI();
        agentState.personaMode =
          agentState.config.personaBalance < 50 ? "XYZ" : "LSD";
        updateStateDisplay();
        clearCurrentCycleDetails();
        logToTimeline(iter, `[STATE] Ready for next cycle.`);
        uiElements.systemGoalInput.value = "";
        uiElements.metaGoalInput.value = "";
        uiElements.runCycleButton.textContent = "Run Cycle";
        uiElements.runCycleButton.disabled = false;
        updateStatusIndicator("Idle");
        highlightCoreStep(-1);
      }

      async function runAutomatedCritiqueAndApply(logicResponse, iteration) {
        logCoreLoopStep(iteration, 5, "Critique: Auto");
        const goalInfo = getActiveGoalAndType();
        const critRes = await runAutoCritique(
          agentState.apiKey,
          logicResponse,
          goalInfo
        );
        const passed = critRes.critique_passed;
        agentState.critiqueFailHistory.push(!passed);
        updateMetricsDisplay();
        logToTimeline(
          iteration,
          `[CRITIQUE] AutoCrit Result: ${
            passed ? "Pass" : "Fail"
          }. Report: ${critRes.critique_report.substring(0, 100)}...`,
          passed ? "info" : "error",
          true
        );
        displayCurrentCycleArtifact(
          "Output: Automated Critique Report",
          critRes.critique_report,
          passed ? "info" : "error"
        );

        let applyResult = {
          success: false,
          changes: [],
          finalState: agentState,
        };
        if (passed) {
          applyResult = applyChanges(logicResponse, iteration, "AutoCrit Pass");
          if (!applyResult.success && !metaSandboxAwaitingApproval) {
            agentState.lastFeedback = `AutoCrit pass, but apply failed.`;
            logToTimeline(
              iteration,
              `[APPLY ERR] Application failed after passing critique.`,
              "error",
              true
            );
          }
        } else {
          agentState.lastFeedback = `AutoCrit fail:${critRes.critique_report}.`;
          alert(`Automated Critique Failed:\n${critRes.critique_report}`);
        }

        if (!metaSandboxAwaitingApproval) {
          agentState = applyResult.finalState; // Update state based on apply result
          if (applyResult.success && passed) agentState.agentIterations++;
          agentState.lastCritiqueType = `Automated (${
            passed ? "Pass" : "Fail"
          })`;

          const summaryOutcome = applyResult.success
            ? `OK (AutoCrit ${passed ? "Pass" : "Fail"})`
            : `Failed (AutoCrit ${passed ? "Pass" : "Fail"}, Apply ${
                applyResult.success ? "OK" : "Fail"
              })`;
          summarizeCompletedCycle(lastCompletedCycleLogItem, summaryOutcome);
          lastCompletedCycleLogItem = null;

          updateStateDisplay();
          clearCurrentCycleDetails();
          logToTimeline(
            iteration,
            `[STATE] Cycle ended (${agentState.lastCritiqueType}). Ready.`
          );
          uiElements.systemGoalInput.value = "";
          uiElements.metaGoalInput.value = "";
          uiElements.runCycleButton.disabled = false;
          uiElements.runCycleButton.textContent = "Run Cycle";
          updateStatusIndicator("Idle");
          highlightCoreStep(-1);
        } else {
          agentState.lastCritiqueType = `Automated (${
            passed ? "Pass" : "Fail"
          })`; // Update type even if sandbox pending
          updateStateDisplay(); // Update metrics etc.
        }
      }
      async function executeCycle() {
        if (lastCompletedCycleLogItem) {
          summarizeCompletedCycle(lastCompletedCycleLogItem, "Interrupted");
          lastCompletedCycleLogItem = null;
        }
        clearCurrentCycleDetails();
        currentAgentResponse = null;
        agentState.currentDiagramSvgData = null;
        agentState.apiKey =
          uiElements.apiKeyInput.value.trim() || APP_CONFIG.API_KEY;
        if (
          !agentState.apiKey ||
          agentState.apiKey === "<nope>" ||
          agentState.apiKey.length < 10
        ) {
          alert("Valid API Key required.");
          return;
        }

        logCoreLoopStep(agentState.totalCycles + 1, 0, "Define Goal"); // Use next cycle number tentatively
        const sysGoal = uiElements.systemGoalInput.value.trim();
        const metaGoal = uiElements.metaGoalInput.value.trim();
        const goals = [
          { goal: sysGoal, type: "System" },
          { goal: metaGoal, type: "Meta" },
        ].filter((g) => g.goal);
        if (goals.length === 0) {
          alert("System or Meta Goal required.");
          return;
        }
        if (goals.length > 1) {
          alert("Provide ONLY ONE goal.");
          return;
        }
        const goalInfo = goals[0];

        // Update goal state *before* incrementing cycle, used by iteration
        agentState.currentGoal.system =
          goalInfo.type === "System" ? goalInfo.goal : null;
        agentState.currentGoal.meta =
          goalInfo.type === "Meta" ? goalInfo.goal : null;
        agentState.currentGoal.type = goalInfo.type;

        const maxC = agentState.config.maxCycles || 0;
        if (maxC > 0 && agentState.totalCycles >= maxC) {
          alert(`Max cycles (${maxC}) reached.`);
          uiElements.runCycleButton.disabled = true;
          return;
        }
        if (agentState.contextTokenEstimate >= CONTEXT_WARNING_THRESHOLD) {
          if (
            !confirm(
              `Context tokens (${agentState.contextTokenEstimate}) high! Continue? Summarize soon.`
            )
          ) {
            return;
          }
        }

        agentState.totalCycles++;
        const iter = agentState.totalCycles;
        uiElements.currentCycleNumber.textContent = iter;
        uiElements.runCycleButton.disabled = true;
        uiElements.runCycleButton.textContent = "Processing...";
        updateStatusIndicator("Starting Cycle...", true);
        updateStateDisplay();
        lastCompletedCycleLogItem = logToTimeline(
          iter,
          `[CYCLE] === Cycle ${iter} Start === Goal: ${goalInfo.type}`
        );
        logToTimeline(
          iter,
          `[GOAL] ${goalInfo.type}: "${goalInfo.goal.substring(0, 70)}..."`,
          "info",
          true
        );
        displayCurrentCycleArtifact(
          "Input: Goal",
          `${goalInfo.type}: ${goalInfo.goal}`,
          "input"
        );
        displayCurrentCycleArtifact(
          "Input: Available Tools",
          getCurrentToolsList(),
          "input"
        );
        displayCurrentCycleArtifact(
          "Input: Current Diagram JSON",
          agentState.currentDiagramJson,
          "input"
        );
        displayCurrentDiagram(
          agentState.currentDiagramJson,
          agentState.currentDiagramSvg,
          false,
          false
        ); // Display initial diagram state for cycle

        logCoreLoopStep(iter, 1, "Analyze");
        const {
          response: logicResp,
          cycleTimeMillis: cycleMs,
          error: iterError,
          requiresSelfCorrection,
        } = await run1729Iteration(agentState.apiKey, agentState, goalInfo);
        const cycleSecs = cycleMs / 1000;

        if (iterError || !logicResp) {
          logToTimeline(
            iter,
            `[CYCLE ERR] Iteration failed: ${iterError || "No response."}`,
            "error",
            true
          );
          displayCurrentCycleArtifact(
            "Output: Iteration Error",
            iterError || "No response.",
            "error"
          );
          agentState.critiqueFailHistory.push(true);
          updateMetricsDisplay();
          if (
            requiresSelfCorrection &&
            !agentState.selfCorrectionAttemptedThisCycle
          ) {
            logToTimeline(
              iter,
              `[STATE] Attempting self-correction...`,
              "warn",
              true
            );
            agentState.selfCorrectionAttemptedThisCycle = true;
            agentState.lastFeedback = `Error: ${iterError}. Attempting self-correction.`;
            updateStatusIndicator("Attempting Self-Correction...", true);
            executeCycle();
            return;
          } else {
            uiElements.runCycleButton.disabled = false;
            uiElements.runCycleButton.textContent = "Run Cycle";
            updateStatusIndicator("Iteration Failed", false, true);
            alert(`Iteration failed: ${iterError || "Unknown"}.`);
            summarizeCompletedCycle(
              lastCompletedCycleLogItem,
              `Error: ${iterError || "No response."}`
            );
            lastCompletedCycleLogItem = null;
            agentState.selfCorrectionAttemptedThisCycle = false;
            highlightCoreStep(-1);
            return;
          }
        }
        agentState.selfCorrectionAttemptedThisCycle = false;
        currentAgentResponse = logicResp;
        logCoreLoopStep(iter, 2, "Propose");
        logCoreLoopStep(iter, 3, "Generate Artifacts");
        // Artifacts are displayed within applyChanges or runAutoCritique

        const confidence = logicResp.agent_confidence_score ?? 0.0;
        agentState.confidenceHistory.push(confidence);
        if (agentState.confidenceHistory.length > 20)
          agentState.confidenceHistory.shift();
        updateMetricsDisplay();

        logCoreLoopStep(iter, 4, "Critique Trigger Check");
        const pauseThresh = agentState.config.pauseAfterCycles || 0;
        const confThresh = agentState.config.autoCritiqueThreshold ?? 0.6;
        const humanProb =
          (agentState.config.humanReviewProbability ?? 36) / 100.0;
        const llmProb = (agentState.config.llmTurnProbability ?? 70) / 100.0;
        const maxTime = agentState.config.maxCycleTime ?? 600;
        let humanNeeded = false;
        let critReason = "";
        let critType = "None";
        let hitlMode = "prompt";

        if (agentState.forceHumanReview) {
          humanNeeded = true;
          critReason = "Forced Review";
          agentState.forceHumanReview = false;
        } else if (pauseThresh > 0 && iter % pauseThresh === 0) {
          humanNeeded = true;
          critReason = `Auto Pause (${iter}/${pauseThresh})`;
        } else if (Math.random() < humanProb) {
          humanNeeded = true;
          critReason = `Random Review (${(humanProb * 100).toFixed(0)}%)`;
        } else if (cycleSecs > maxTime) {
          humanNeeded = true;
          critReason = `Time Limit Exceeded (${cycleSecs.toFixed(
            1
          )}s > ${maxTime}s)`;
        } else if (confidence < confThresh) {
          humanNeeded = true;
          critReason = `Low Confidence (${confidence.toFixed(
            2
          )} < ${confThresh})`;
        }

        logToTimeline(
          iter,
          `[DECISION] Time:${cycleSecs.toFixed(1)}s, Conf:${confidence.toFixed(
            2
          )}. Human Needed: ${humanNeeded ? critReason : "No"}.`,
          "info",
          true
        );

        if (humanNeeded) {
          critType = "Human";
          agentState.critiqueFailHistory.push(false);
          logCoreLoopStep(
            iter,
            5,
            `Critique: Human Intervention (${critReason})`
          );
          updateStatusIndicator(`Paused: Human Review (${critReason})`);
          const modes = ["prompt", "code_edit"];
          hitlMode = modes[Math.floor(Math.random() * modes.length)];
          let editArt = {
            type: "body_html",
            content: logicResp.body_html ?? agentState.currentBodyHtml ?? "",
          };
          if (logicResp.full_html_source)
            editArt = {
              type: "full_html_source",
              content: logicResp.full_html_source,
            };
          else if (logicResp.script_js_array !== null)
            editArt = {
              type: "script_js_array",
              content:
                logicResp.script_js_array
                  ?.map((s) => `/* ID: ${s.id} */\n${s.content}`)
                  .join("\n\n") || "",
            };
          else if (logicResp.style_css !== null)
            editArt = { type: "style_css", content: logicResp.style_css };
          else if (logicResp.head_html !== null)
            editArt = { type: "head_html", content: logicResp.head_html };
          else if (logicResp.updated_diagram_json !== null)
            editArt = {
              type: "diagram_json",
              content: JSON.stringify(logicResp.updated_diagram_json, null, 2),
            };

          showHumanInterventionUI(hitlMode, critReason, [], editArt);
          // Cycle conclusion happens in proceedAfterCritique
        } else {
          if (Math.random() < llmProb) {
            critType = "Automated";
            logToTimeline(
              iter,
              `[DECISION] Triggering Auto Critique (${(llmProb * 100).toFixed(
                0
              )}% chance).`,
              "info",
              true
            );
            await runAutomatedCritiqueAndApply(logicResp, iter);
            // Cycle conclusion happens within runAutomatedCritiqueAndApply
          } else {
            critType = "Skipped";
            agentState.critiqueFailHistory.push(false);
            logCoreLoopStep(iter, 5, "Critique: Skipped");
            logToTimeline(
              iter,
              `[DECISION] Critique Skipped (Below ${(llmProb * 100).toFixed(
                0
              )}% threshold). Applying changes directly.`,
              "info",
              true
            );
            updateStatusIndicator("Applying Changes (Critique Skipped)...");
            const applyResult = applyChanges(logicResp, iter, "Skipped");
            logCoreLoopStep(iter, 6, "Refine & Apply");

            if (!metaSandboxAwaitingApproval) {
              agentState = applyResult.finalState; // Update state
              if (applyResult.success) {
                agentState.agentIterations++;
                agentState.lastFeedback =
                  "Skipped critique, applied successfully.";
              } else {
                agentState.lastFeedback = "Skipped critique, apply failed.";
              }
              agentState.lastCritiqueType = `Skipped (${
                applyResult.success ? "Applied" : "Apply Fail"
              })`;

              const summaryOutcome = applyResult.success
                ? `OK (Critique Skipped)`
                : `Failed (Apply Fail after Skip)`;
              summarizeCompletedCycle(
                lastCompletedCycleLogItem,
                summaryOutcome
              );
              lastCompletedCycleLogItem = null;

              updateStateDisplay();
              clearCurrentCycleDetails();
              logCoreLoopStep(iter, 7, "Repeat/Pause");
              logToTimeline(
                iter,
                `[STATE] Cycle ended (${agentState.lastCritiqueType}). Ready.`
              );
              uiElements.systemGoalInput.value = "";
              uiElements.metaGoalInput.value = "";
              uiElements.runCycleButton.disabled = false;
              uiElements.runCycleButton.textContent = "Run Cycle";
              updateStatusIndicator("Idle");
              highlightCoreStep(-1);
            } else {
              agentState.lastCritiqueType = `Skipped (Sandbox Pending)`;
              updateStateDisplay(); // Update metrics etc.
            }
          }
        }
      }

      function downloadLogs() {
        const blob = new Blob([logBuffer], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `1729_log_${new Date()
          .toISOString()
          .replace(/[:.]/g, "-")}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        logEvent("info", "Log download.");
      }
      function capturePreservationState() {
        const ui = {
          systemGoal: uiElements.systemGoalInput.value,
          metaGoal: uiElements.metaGoalInput.value,
          apiKey: uiElements.apiKeyInput.value,
        };
        return {
          version: STATE_FILE_VERSION,
          agentState: agentState,
          logBuffer: logBuffer,
          timelineHTML: uiElements.timelineLog.innerHTML,
          uiInputValues: ui,
          currentAgentResponse: currentAgentResponse,
          metaSandboxAwaitingApproval: metaSandboxAwaitingApproval,
        };
      }
      function exportState() {
        const state = capturePreservationState();
        const fileName = `1729_state_${new Date()
          .toISOString()
          .replace(/[:.]/g, "-")}.json`;
        const data = JSON.stringify(state, null, 2);
        logEvent("info", "State export initiated.");
        try {
          const blob = new Blob([data], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          logToTimeline(
            agentState.totalCycles,
            "[STATE] State exported successfully.",
            "info"
          );
        } catch (e) {
          logEvent("error", `Export failed: ${e.message}`);
          alert(`Export failed.`);
          logToTimeline(
            agentState.totalCycles,
            "[STATE] State export failed.",
            "error"
          );
        }
      }
      function importState() {
        uiElements.importFileInput.click();
      }
      function handleImportFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const imported = JSON.parse(e.target.result);
            if (!imported.version || typeof imported.version !== "string")
              throw new Error("State missing version.");
            logEvent("info", `Importing state v${imported.version}`);
            const impMaj = imported.version.split(".").slice(0, 2).join(".");
            const curMaj = STATE_FILE_VERSION.split(".").slice(0, 2).join(".");
            // Allow importing slightly older versions for flexibility
            if (
              impMaj !== curMaj &&
              !["0.0", "0.1", "0.2"].includes(imported.version)
            )
              logEvent(
                "warn",
                `Version mismatch ${imported.version} vs ${STATE_FILE_VERSION}. May cause issues.`
              );

            const def = getDefaultAgentState();
            agentState = {
              ...def,
              ...imported.agentState,
              config: { ...def.config, ...(imported.agentState?.config || {}) },
              dynamicTools: imported.agentState?.dynamicTools || [],
              htmlHistory: imported.agentState?.htmlHistory || [],
              confidenceHistory: imported.agentState?.confidenceHistory || [],
              critiqueFailHistory:
                imported.agentState?.critiqueFailHistory || [],
              tokenHistory: imported.agentState?.tokenHistory || [],
              coreElementIds: imported.agentState?.coreElementIds || [
                ...CORE_ELEMENT_IDS,
              ],
              genesisStateSnapshot:
                imported.agentState?.genesisStateSnapshot || null,
            };
            agentState.version = STATE_FILE_VERSION;
            logBuffer = imported.logBuffer || logBuffer;
            uiElements.timelineLog.innerHTML = imported.timelineHTML || "";
            currentAgentResponse = imported.currentAgentResponse || null;
            metaSandboxAwaitingApproval =
              imported.metaSandboxAwaitingApproval || false;
            uiElements.systemGoalInput.value =
              imported.uiInputValues?.systemGoal || "";
            uiElements.metaGoalInput.value =
              imported.uiInputValues?.metaGoal || "";
            uiElements.apiKeyInput.value =
              imported.uiInputValues?.apiKey || agentState.apiKey || "";

            clearCurrentCycleDetails();
            if (
              metaSandboxAwaitingApproval &&
              agentState.lastGeneratedFullSource
            ) {
              showMetaSandbox(agentState.lastGeneratedFullSource);
            }

            updateStateDisplay();
            displayGenesisState();
            logEvent("info", "State imported.");
            logToTimeline(
              agentState.totalCycles,
              "[STATE] State imported successfully.",
              "info"
            );
            alert("State imported successfully.");
          } catch (err) {
            logEvent("error", `Import failed: ${err.message}`);
            alert(`Import failed: ${err.message}`);
            logToTimeline(
              agentState.totalCycles,
              `[STATE] State import failed: ${err.message}`,
              "error"
            );
          } finally {
            uiElements.importFileInput.value = "";
          }
        };
        reader.onerror = (e) => {
          logEvent("error", `File read error: ${reader.error}`);
          alert(`Error reading file.`);
          uiElements.importFileInput.value = "";
        };
        reader.readAsText(file);
      }
      function restoreStateFromStorage() {
        const json = sessionStorage.getItem(STATE_STORAGE_KEY);
        if (!json) return false;
        logEvent(
          "info",
          "Preserved state found from self-modification reload."
        );
        try {
          const preserved = JSON.parse(json);
          const impMaj = preserved.version.split(".").slice(0, 2).join(".");
          const curMaj = STATE_FILE_VERSION.split(".").slice(0, 2).join(".");
          if (
            impMaj !== curMaj &&
            !["0.0", "0.1", "0.2"].includes(preserved.version)
          )
            logEvent("warn", `Restoring older state v${preserved.version}.`);
          const def = getDefaultAgentState();
          agentState = {
            ...def,
            ...preserved.agentState,
            config: { ...def.config, ...(preserved.agentState?.config || {}) },
            dynamicTools: preserved.agentState?.dynamicTools || [],
            htmlHistory: preserved.agentState?.htmlHistory || [],
            confidenceHistory: preserved.agentState?.confidenceHistory || [],
            critiqueFailHistory:
              preserved.agentState?.critiqueFailHistory || [],
            tokenHistory: preserved.agentState?.tokenHistory || [],
            coreElementIds: preserved.agentState?.coreElementIds || [
              ...CORE_ELEMENT_IDS,
            ],
            genesisStateSnapshot:
              preserved.agentState?.genesisStateSnapshot || null,
          };
          agentState.version = STATE_FILE_VERSION;
          logBuffer = preserved.logBuffer || logBuffer;
          uiElements.timelineLog.innerHTML = preserved.timelineHTML || "";
          currentAgentResponse = preserved.currentAgentResponse || null;
          metaSandboxAwaitingApproval =
            preserved.metaSandboxAwaitingApproval || false;

          uiElements.systemGoalInput.value =
            preserved.uiInputValues?.systemGoal || "";
          uiElements.metaGoalInput.value =
            preserved.uiInputValues?.metaGoal || "";
          uiElements.apiKeyInput.value =
            preserved.uiInputValues?.apiKey || agentState.apiKey || "";
          updateStateDisplay();
          displayGenesisState();
          logEvent("info", "State restored after self-modification.");
          logToTimeline(
            agentState.totalCycles,
            "[STATE] Restored after self-modification."
          );
          uiElements.runCycleButton.disabled = metaSandboxAwaitingApproval;
          uiElements.runCycleButton.textContent = "Run Cycle";
          updateStatusIndicator(
            metaSandboxAwaitingApproval
              ? "Awaiting Meta Sandbox Approval..."
              : "Idle"
          );
        } catch (e) {
          logEvent("error", `Restore failed: ${e.message}`);
          alert(`Restore failed. Reinitializing.`);
          agentState = getDefaultAgentState();
          genesisStateSnapshot = captureGenesisState(agentState);
          agentState.genesisStateSnapshot = genesisStateSnapshot;
          updateStateDisplay();
          displayGenesisState();
          logToTimeline(0, "[STATE] Restore failed. Reinitialized.", "error");
          updateStatusIndicator("Restore Failed", false, true);
        } finally {
          sessionStorage.removeItem(STATE_STORAGE_KEY);
          logEvent("info", "Cleared preserved state.");
        }
        return true;
      }
      function goBackOneStep() {
        if (!agentState.htmlHistory?.length) {
          alert("No history to go back to.");
          return;
        }
        if (
          !confirm(
            "This will revert the entire page to the previous version. Current state will be preserved for reload. Continue?"
          )
        )
          return;

        const prevHtml = agentState.htmlHistory.pop();
        updateHtmlHistoryControls();
        logEvent("info", `Reverting HTML via Go Back.`);
        logToTimeline(
          agentState.totalCycles,
          "[STATE] Reverting HTML to previous version.",
          "warn"
        );
        const state = capturePreservationState();
        state.agentState.htmlHistory = [...agentState.htmlHistory];
        try {
          sessionStorage.setItem(STATE_STORAGE_KEY, JSON.stringify(state));
          document.open();
          document.write(prevHtml);
          document.close();
        } catch (e) {
          logEvent("error", `Go Back failed: ${e.message}`);
          alert(`Go Back failed.`);
          sessionStorage.removeItem(STATE_STORAGE_KEY);
          agentState.htmlHistory.push(prevHtml);
          updateHtmlHistoryControls();
        }
      }
      async function handleSummarizeContext() {
        if (!agentState || !agentState.apiKey) {
          alert("API Key is required for summarization.");
          return;
        }
        if (
          !confirm(
            "This will use the LLM to summarize the current state and goal, potentially reducing context token usage for future cycles, but may lose detail. Continue?"
          )
        )
          return;

        updateStatusIndicator("Summarizing context...", true);
        logToTimeline(
          agentState.totalCycles,
          "[CONTEXT] Starting context summarization...",
          "info"
        );
        clearCurrentCycleDetails(); // Clear current display while summarizing

        try {
          // Create a snapshot of relevant state parts for the LLM
          const stateSnapshot = {
            totalCycles: agentState.totalCycles,
            agentIterations: agentState.agentIterations,
            humanInterventions: agentState.humanInterventions,
            currentGoal: agentState.currentGoal,
            lastCritiqueType: agentState.lastCritiqueType,
            lastFeedback: agentState.lastFeedback,
            avgConfidence: agentState.avgConfidence,
            critiqueFailRate: agentState.critiqueFailRate,
            dynamicTools: agentState.dynamicTools.map(
              (t) => t.declaration.name
            ), // Just names
            // Include current artifact states if needed, but keep it brief to avoid large context for summarizer
            currentDiagramJson:
              agentState.currentDiagramJson?.substring(0, 500) +
              (agentState.currentDiagramJson?.length > 500 ? "..." : ""),
            // Potentially add snippets of HTML/CSS/JS if crucial
          };

          const summary = await runSummarization(
            agentState.apiKey,
            stateSnapshot
          );

          agentState.currentGoal.summaryContext = summary;
          agentState.contextTokenEstimate = Math.round(
            (summary.length / 4) * 1.1
          ); // Estimate new context size based on summary + overhead
          agentState.lastFeedback = `Context summarized from Cycle ${agentState.totalCycles}.`; // Update feedback
          agentState.lastCritiqueType = "Context Summary"; // Update critique type

          logToTimeline(
            agentState.totalCycles,
            `[CONTEXT] Context summarized. New estimated tokens: ${agentState.contextTokenEstimate}. Ready for next goal.`,
            "info"
          );
          displayCurrentCycleArtifact(
            "Output: Generated Context Summary",
            summary,
            "output",
            true
          );
          alert(
            "Context summarized successfully. The summary will be included in the next LLM call. Estimated context tokens have been reduced."
          );
        } catch (error) {
          logEvent("error", `Summarization failed: ${error.message}`);
          alert(`Summarization failed: ${error.message}`);
          logToTimeline(
            agentState.totalCycles,
            `[CONTEXT ERR] Summarization failed: ${error.message}`,
            "error"
          );
        } finally {
          updateStateDisplay(); // Update goal display etc.
          updateStatusIndicator("Idle");
          highlightCoreStep(-1);
        }
      }

      function captureGenesisState(state) {
        return {
          metrics: uiElements.genesisMetricsDisplay.innerHTML,
          diagramSvg: state.currentDiagramSvg,
          diagramJson: state.currentDiagramJson,
        };
      }

      function handlePersonaInput() {
        let lsd = parseInt(uiElements.lsdPersonaPercentInput.value, 10) || 0;
        lsd = Math.max(0, Math.min(100, lsd));

        agentState.config.personaBalance = lsd;
        uiElements.lsdPersonaPercentInput.value = lsd;
        uiElements.xyzPersonaPercentInput.value = 100 - lsd;

        logEvent("info", `Config 'personaBalance' (LSD %) = ${lsd}`);
      }

      function initialize() {
        logEvent("info", `Initializing 1729 Engine v0.0.3`);
        updateStatusIndicator("Initializing...");
        const restored = restoreStateFromStorage();
        if (!restored) {
          agentState = getDefaultAgentState();
          agentState.apiKey =
            APP_CONFIG.API_KEY && APP_CONFIG.API_KEY !== "<nope>"
              ? APP_CONFIG.API_KEY
              : "";
          genesisStateSnapshot = captureGenesisState(agentState);
          agentState.genesisStateSnapshot = genesisStateSnapshot;
          updateStateDisplay();
          displayGenesisState();
          logToTimeline(0, "[STATE] System Initialized.");
          updateStatusIndicator("Idle");
        } else {
          if (
            metaSandboxAwaitingApproval &&
            agentState.lastGeneratedFullSource
          ) {
            showMetaSandbox(agentState.lastGeneratedFullSource);
          }
        }
        highlightCoreStep(-1);

        uiElements.runCycleButton.addEventListener("click", executeCycle);
        uiElements.submitCritiqueButton.addEventListener("click", () =>
          proceedAfterCritique(
            "Human Prompt",
            uiElements.humanCritiqueInput.value.trim()
          )
        );
        uiElements.submitHitlOptionsButton.addEventListener("click", () => {
          const selected = Array.from(
            uiElements.hitlOptionsList.querySelectorAll("input:checked")
          )
            .map((el) => el.value)
            .join(", ");
          proceedAfterCritique("Human Options", selected || "None");
        });
        uiElements.submitHumanCodeEditButton.addEventListener("click", () => {
          const type = uiElements.humanEditArtifactSelector.value;
          const content = uiElements.humanEditArtifactTextarea.value;
          let applySuccess = true;
          let changes = [];
          try {
            if (type === "diagram_json") {
              const newJson = JSON.stringify(JSON.parse(content), null, 2);
              if (newJson !== agentState.currentDiagramJson) {
                agentState.currentDiagramJson = newJson;
                agentState.currentDiagramSvg = null;
                changes.push("Diagram JSON");
                logToTimeline(
                  agentState.totalCycles,
                  `[HUMAN] Edited Diagram JSON.`,
                  "info",
                  true
                );
                displayCurrentDiagram(
                  agentState.currentDiagramJson,
                  agentState.currentDiagramSvg,
                  true,
                  false
                );
              }
            } else if (type === "head_html") {
              if (content !== agentState.currentHeadHtml) {
                agentState.currentHeadHtml = content;
                changes.push("Head HTML");
              }
            } else if (type === "body_html") {
              if (content !== agentState.currentBodyHtml) {
                agentState.currentBodyHtml = content;
                changes.push("Body HTML");
              }
            } else if (type === "style_css") {
              if (content !== agentState.currentStyleCss) {
                agentState.currentStyleCss = content;
                changes.push("Style CSS");
              }
            } else if (type === "full_html_source") {
              if (content !== agentState.lastGeneratedFullSource) {
                agentState.lastGeneratedFullSource = content;
                changes.push("Full HTML Source");
                logEvent("warn", "Full source edited, cannot apply directly.");
                applySuccess = false;
                alert(
                  "Full source edited, but cannot be applied directly. Use sandbox if applicable or provide feedback."
                );
              }
            } else if (type === "script_js_array") {
              logEvent(
                "warn",
                "Human edit of JS array assumes single script block."
              );
              const newArr = [{ id: "human_edited", content: content }];
              if (
                JSON.stringify(newArr) !==
                JSON.stringify(agentState.currentScriptJsArray)
              ) {
                agentState.currentScriptJsArray = newArr;
                changes.push("Script JS Array");
              }
            } else {
              applySuccess = false;
              logEvent(
                "error",
                `Unknown artifact type for human edit: ${type}`
              );
            }

            if (applySuccess && changes.length > 0) {
              logEvent("info", `Applied human edit to ${changes.join(", ")}`);
              proceedAfterCritique(
                "Human Code Edit",
                `Edited ${changes.join(", ")}`
              );
              if (
                changes.some((c) =>
                  [
                    "Head HTML",
                    "Body HTML",
                    "Style CSS",
                    "Script JS Array",
                  ].includes(c)
                )
              ) {
                renderGeneratedUI(
                  agentState.currentHeadHtml,
                  agentState.currentBodyHtml,
                  agentState.currentStyleCss,
                  agentState.currentScriptJsArray
                );
              }
            } else if (applySuccess && changes.length === 0) {
              proceedAfterCritique(
                "Human Code Edit",
                `No changes detected for ${type}`,
                true
              ); // No changes, don't count intervention
            } else {
              proceedAfterCritique(
                "Human Edit Failed",
                `Could not apply edit to ${type}`,
                true
              );
            }
          } catch (e) {
            logEvent(
              "error",
              `Error applying human edit to ${type}: ${e.message}`
            );
            alert(`Error applying edit: ${e.message}`);
            proceedAfterCritique(
              "Human Edit Failed",
              `Error applying edit to ${type}: ${e.message}`,
              true
            );
          }
        });
        uiElements.forceHumanReviewButton.addEventListener("click", () => {
          agentState.forceHumanReview = true;
          alert("Next cycle will be forced into Human Review.");
          logToTimeline(
            agentState.totalCycles,
            "[HUMAN] User forced Human Review for next cycle.",
            "warn"
          );
        });
        uiElements.downloadLogButton.addEventListener("click", downloadLogs);
        uiElements.exportStateButton.addEventListener("click", exportState);
        uiElements.summarizeContextButton.addEventListener(
          "click",
          handleSummarizeContext
        );
        uiElements.importStateButton.addEventListener("click", importState);
        uiElements.importFileInput.addEventListener("change", handleImportFile);
        uiElements.goBackButton.addEventListener("click", goBackOneStep);
        uiElements.approveMetaChangeButton.addEventListener("click", () => {
          if (
            metaSandboxAwaitingApproval &&
            agentState.lastGeneratedFullSource
          ) {
            const src = agentState.lastGeneratedFullSource;
            logEvent("info", "Approved meta-change from sandbox.");
            logToTimeline(
              agentState.totalCycles,
              `[STATE] Approved Meta-Sandbox changes. Applying...`,
              "info",
              true
            );
            hideMetaSandbox();
            const currentHtml = document.documentElement.outerHTML;
            saveHtmlToHistory(currentHtml);
            const state = capturePreservationState();
            state.metaSandboxAwaitingApproval = false;
            try {
              sessionStorage.setItem(STATE_STORAGE_KEY, JSON.stringify(state));
              document.open();
              document.write(src);
              document.close();
            } catch (e) {
              logEvent("error", `Apply meta failed: ${e.message}`);
              alert(`Apply failed: ${e.message}`);
              sessionStorage.removeItem(STATE_STORAGE_KEY);
              if (agentState.htmlHistory.length > 0)
                agentState.htmlHistory.pop();
              updateHtmlHistoryControls();
              window.location.reload();
            }
          } else {
            alert("No sandbox content to approve or state mismatch.");
          }
        });
        uiElements.discardMetaChangeButton.addEventListener("click", () => {
          logEvent("info", "Discarded meta-sandbox changes.");
          logToTimeline(
            agentState.totalCycles,
            `[STATE] Discarded Meta-Sandbox changes.`,
            "warn",
            true
          );
          hideMetaSandbox();
          agentState.lastFeedback = "User discarded meta-sandbox changes.";
          proceedAfterCritique(
            "Sandbox Discarded",
            "User discarded changes",
            true
          );
        });

        uiElements.lsdPersonaPercentInput.addEventListener(
          "input",
          handlePersonaInput
        );

        Object.keys(agentState.config).forEach((key) => {
          if (key === "personaBalance") return;
          const input = uiElements[key + "Input"];
          if (input) {
            input.addEventListener("change", (e) => {
              let value;
              if (e.target.type === "number") {
                value =
                  e.target.step === "any" || e.target.step.includes(".")
                    ? parseFloat(e.target.value)
                    : parseInt(e.target.value, 10);
              } else {
                value = e.target.value;
              }
              if (agentState.config[key] !== value) {
                agentState.config[key] = value;
                logEvent("info", `Config '${key}' = ${value}`);
                if (key === "maxCycles")
                  uiElements.maxCyclesDisplay.textContent =
                    value === 0 ? "Inf" : value.toString();
                if (key === "htmlHistoryLimit") updateHtmlHistoryControls();
              }
            });
          }
        });
      }
      initialize();
    </script>
  </body>
</html>
